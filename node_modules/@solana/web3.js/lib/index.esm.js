import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import nacl from 'tweetnacl';
import BN from 'bn.js';
import bs58 from 'bs58';
import hasha from 'hasha';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import { blob, struct, ns64, u32, offset, u8, seq, nu64 } from 'buffer-layout';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import assert from 'assert';
import { parse, format } from 'url';
import fetch from 'node-fetch';
import jayson from 'jayson/lib/client/browser';
import { struct as struct$1 } from 'superstruct';
import { Client } from 'rpc-websockets';

var toBuffer = function toBuffer(arr) {
  if (arr instanceof Buffer) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return Buffer.from(arr);
  }
};

/**
 * A public key
 */

var PublicKey = /*#__PURE__*/function () {
  /**
   * Create a new PublicKey object
   */
  function PublicKey(value) {
    _classCallCheck(this, PublicKey);

    _defineProperty(this, "_bn", void 0);

    if (typeof value === 'string') {
      // hexadecimal number
      if (value.startsWith('0x')) {
        this._bn = new BN(value.substring(2), 16);
      } else {
        // assume base 58 encoding by default
        var decoded = bs58.decode(value);

        if (decoded.length != 32) {
          throw new Error("Invalid public key input");
        }

        this._bn = new BN(decoded);
      }
    } else {
      this._bn = new BN(value);
    }

    if (this._bn.byteLength() > 32) {
      throw new Error("Invalid public key input");
    }
  }
  /**
   * Checks if the provided object is a PublicKey
   */


  _createClass(PublicKey, [{
    key: "equals",

    /**
     * Checks if two publicKeys are equal
     */
    value: function equals(publicKey) {
      return this._bn.eq(publicKey._bn);
    }
    /**
     * Return the base-58 representation of the public key
     */

  }, {
    key: "toBase58",
    value: function toBase58() {
      return bs58.encode(this.toBuffer());
    }
    /**
     * Return the Buffer representation of the public key
     */

  }, {
    key: "toBuffer",
    value: function toBuffer() {
      var b = this._bn.toArrayLike(Buffer);

      if (b.length === 32) {
        return b;
      }

      var zeroPad = Buffer.alloc(32);
      b.copy(zeroPad, 32 - b.length);
      return zeroPad;
    }
    /**
     * Returns a string representation of the public key
     */

  }, {
    key: "toString",
    value: function toString() {
      return this.toBase58();
    }
    /**
     * Derive a public key from another key, a seed, and a programId.
     */

  }], [{
    key: "isPublicKey",
    value: function isPublicKey(o) {
      return o instanceof PublicKey;
    }
  }, {
    key: "createWithSeed",
    value: function createWithSeed(fromPublicKey, seed, programId) {
      var buffer = Buffer.concat([fromPublicKey.toBuffer(), Buffer.from(seed), programId.toBuffer()]);
      var hash = hasha(buffer, {
        algorithm: 'sha256'
      });
      return new PublicKey('0x' + hash);
    }
  }]);

  return PublicKey;
}();

/**
 * An account key pair (public and secret keys).
 */

var Account = /*#__PURE__*/function () {
  /**
   * Create a new Account object
   *
   * If the secretKey parameter is not provided a new key pair is randomly
   * created for the account
   *
   * @param secretKey Secret key for the account
   */
  function Account(secretKey) {
    _classCallCheck(this, Account);

    _defineProperty(this, "_keypair", void 0);

    if (secretKey) {
      this._keypair = nacl.sign.keyPair.fromSecretKey(toBuffer(secretKey));
    } else {
      this._keypair = nacl.sign.keyPair();
    }
  }
  /**
   * The public key for this account
   */


  _createClass(Account, [{
    key: "publicKey",
    get: function get() {
      return new PublicKey(this._keypair.publicKey);
    }
    /**
     * The **unencrypted** secret key for this account
     */

  }, {
    key: "secretKey",
    get: function get() {
      return this._keypair.secretKey;
    }
  }]);

  return Account;
}();

// TODO: These constants should be removed in favor of reading them out of a
// Syscall account

/**
 * @ignore
 */
var NUM_TICKS_PER_SECOND = 10;
/**
 * @ignore
 */

var DEFAULT_TICKS_PER_SLOT = 8;

/**
 * Layout for a public key
 */

var publicKey = function publicKey() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'publicKey';
  return blob(32, property);
};
/**
 * Layout for a Rust String type
 */

var rustString = function rustString() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'string';
  var rsl = struct([u32('length'), u32('lengthPadding'), blob(offset(u32(), -8), 'chars')], property);

  var _decode = rsl.decode.bind(rsl);

  var _encode = rsl.encode.bind(rsl);

  rsl.decode = function (buffer, offset) {
    var data = _decode(buffer, offset);

    return data.chars.toString('utf8');
  };

  rsl.encode = function (str, buffer, offset) {
    var data = {
      chars: Buffer.from(str, 'utf8')
    };
    return _encode(data, buffer, offset);
  };

  rsl.alloc = function (str) {
    return u32().span + u32().span + Buffer.from(str, 'utf8').length;
  };

  return rsl;
};
/**
 * Layout for an Authorized object
 */

var authorized = function authorized() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'authorized';
  return struct([publicKey('staker'), publicKey('withdrawer')], property);
};
/**
 * Layout for a Lockup object
 */

var lockup = function lockup() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'lockup';
  return struct([ns64('unixTimestamp'), ns64('epoch'), publicKey('custodian')], property);
};
function getAlloc(type, fields) {
  var alloc = 0;
  type.layout.fields.forEach(function (item) {
    if (item.span >= 0) {
      alloc += item.span;
    } else if (typeof item.alloc === 'function') {
      alloc += item.alloc(fields[item.property]);
    }
  });
  return alloc;
}

function decodeLength(bytes) {
  var len = 0;
  var size = 0;

  for (;;) {
    var elem = bytes.shift();
    len |= (elem & 0x7f) << size * 7;
    size += 1;

    if ((elem & 0x80) === 0) {
      break;
    }
  }

  return len;
}
function encodeLength(bytes, len) {
  var rem_len = len;

  for (;;) {
    var elem = rem_len & 0x7f;
    rem_len >>= 7;

    if (rem_len == 0) {
      bytes.push(elem);
      break;
    } else {
      elem |= 0x80;
      bytes.push(elem);
    }
  }
}

/**
 * Default (empty) signature
 *
 * Signatures are 64 bytes in length
 */
var DEFAULT_SIGNATURE = Buffer.alloc(64).fill(0);
/**
 * Maximum over-the-wire size of a Transaction
 *
 * 1280 is IPv6 minimum MTU
 * 40 bytes is the size of the IPv6 header
 * 8 bytes is the size of the fragment header
 */

var PACKET_DATA_SIZE = 1280 - 40 - 8;
var PUBKEY_LENGTH = 32;
var SIGNATURE_LENGTH = 64;
/**
 * List of TransactionInstruction object fields that may be initialized at construction
 *
 * @typedef {Object} TransactionInstructionCtorFields
 * @property {?Array<PublicKey>} keys
 * @property {?PublicKey} programId
 * @property {?Buffer} data
 */

/**
 * Transaction Instruction class
 */
var TransactionInstruction =
/**
 * Public keys to include in this transaction
 * Boolean represents whether this pubkey needs to sign the transaction
 */

/**
 * Program Id to execute
 */

/**
 * Program input
 */
function TransactionInstruction(opts) {
  _classCallCheck(this, TransactionInstruction);

  _defineProperty(this, "keys", []);

  _defineProperty(this, "programId", void 0);

  _defineProperty(this, "data", Buffer.alloc(0));

  opts && Object.assign(this, opts);
};
/**
 * @private
 */

/**
 * Transaction class
 */
var Transaction = /*#__PURE__*/function () {
  _createClass(Transaction, [{
    key: "signature",

    /**
     * Signatures for the transaction.  Typically created by invoking the
     * `sign()` method
     */

    /**
     * The first (payer) Transaction signature
     */
    get: function get() {
      if (this.signatures.length > 0) {
        return this.signatures[0].signature;
      }

      return null;
    }
    /**
     * The instructions to atomically execute
     */

  }]);

  /**
   * Construct an empty Transaction
   */
  function Transaction(opts) {
    _classCallCheck(this, Transaction);

    _defineProperty(this, "signatures", []);

    _defineProperty(this, "instructions", []);

    _defineProperty(this, "recentBlockhash", void 0);

    _defineProperty(this, "nonceInfo", void 0);

    opts && Object.assign(this, opts);
  }
  /**
   * Add one or more instructions to this Transaction
   */


  _createClass(Transaction, [{
    key: "add",
    value: function add() {
      var _this = this;

      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
        items[_key] = arguments[_key];
      }

      if (items.length === 0) {
        throw new Error('No instructions');
      }

      items.forEach(function (item) {
        if (item instanceof Transaction) {
          _this.instructions = _this.instructions.concat(item.instructions);
        } else if (item instanceof TransactionInstruction) {
          _this.instructions.push(item);
        } else {
          _this.instructions.push(new TransactionInstruction(item));
        }
      });
      return this;
    }
    /**
     * @private
     */

  }, {
    key: "_getSignData",
    value: function _getSignData() {
      var _this2 = this;

      var nonceInfo = this.nonceInfo;

      if (nonceInfo && this.instructions[0] != nonceInfo.nonceInstruction) {
        this.recentBlockhash = nonceInfo.nonce;
        this.instructions.unshift(nonceInfo.nonceInstruction);
      }

      var recentBlockhash = this.recentBlockhash;

      if (!recentBlockhash) {
        throw new Error('Transaction recentBlockhash required');
      }

      if (this.instructions.length < 1) {
        throw new Error('No instructions provided');
      }

      var keys = this.signatures.map(function (_ref) {
        var publicKey = _ref.publicKey;
        return publicKey.toString();
      });
      var numReadonlySignedAccounts = 0;
      var numReadonlyUnsignedAccounts = 0;
      var programIds = [];
      var allKeys = [];
      this.instructions.forEach(function (instruction) {
        instruction.keys.forEach(function (keySignerPair) {
          allKeys.push(keySignerPair);
        });
        var programId = instruction.programId.toString();

        if (!programIds.includes(programId)) {
          programIds.push(programId);
        }
      });
      allKeys.sort(function (x, y) {
        var checkSigner = x.isSigner === y.isSigner ? 0 : x.isSigner ? -1 : 1;
        var checkWritable = x.isWritable === y.isWritable ? 0 : x.isWritable ? -1 : 1;
        return checkSigner || checkWritable;
      });
      allKeys.forEach(function (keySignerPair) {
        var keyStr = keySignerPair.pubkey.toString();

        if (!keys.includes(keyStr)) {
          if (keySignerPair.isSigner) {
            _this2.signatures.push({
              signature: null,
              publicKey: keySignerPair.pubkey
            });

            if (!keySignerPair.isWritable) {
              numReadonlySignedAccounts += 1;
            }
          } else {
            if (!keySignerPair.isWritable) {
              numReadonlyUnsignedAccounts += 1;
            }
          }

          keys.push(keyStr);
        }
      });
      programIds.forEach(function (programId) {
        if (!keys.includes(programId)) {
          keys.push(programId);
          numReadonlyUnsignedAccounts += 1;
        }
      });
      var keyCount = [];
      encodeLength(keyCount, keys.length);
      var instructions = this.instructions.map(function (instruction) {
        var data = instruction.data,
            programId = instruction.programId;
        var keyIndicesCount = [];
        encodeLength(keyIndicesCount, instruction.keys.length);
        var dataCount = [];
        encodeLength(dataCount, instruction.data.length);
        return {
          programIdIndex: keys.indexOf(programId.toString()),
          keyIndicesCount: Buffer.from(keyIndicesCount),
          keyIndices: Buffer.from(instruction.keys.map(function (keyObj) {
            return keys.indexOf(keyObj.pubkey.toString());
          })),
          dataLength: Buffer.from(dataCount),
          data: data
        };
      });
      instructions.forEach(function (instruction) {
        assert(instruction.programIdIndex >= 0);
        instruction.keyIndices.forEach(function (keyIndex) {
          return assert(keyIndex >= 0);
        });
      });
      var instructionCount = [];
      encodeLength(instructionCount, instructions.length);
      var instructionBuffer = Buffer.alloc(PACKET_DATA_SIZE);
      Buffer.from(instructionCount).copy(instructionBuffer);
      var instructionBufferLength = instructionCount.length;
      instructions.forEach(function (instruction) {
        var instructionLayout = struct([u8('programIdIndex'), blob(instruction.keyIndicesCount.length, 'keyIndicesCount'), seq(u8('keyIndex'), instruction.keyIndices.length, 'keyIndices'), blob(instruction.dataLength.length, 'dataLength'), seq(u8('userdatum'), instruction.data.length, 'data')]);
        var length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
        instructionBufferLength += length;
      });
      instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
      var signDataLayout = struct([blob(1, 'numRequiredSignatures'), blob(1, 'numReadonlySignedAccounts'), blob(1, 'numReadonlyUnsignedAccounts'), blob(keyCount.length, 'keyCount'), seq(publicKey('key'), keys.length, 'keys'), publicKey('recentBlockhash')]);
      var transaction = {
        numRequiredSignatures: Buffer.from([this.signatures.length]),
        numReadonlySignedAccounts: Buffer.from([numReadonlySignedAccounts]),
        numReadonlyUnsignedAccounts: Buffer.from([numReadonlyUnsignedAccounts]),
        keyCount: Buffer.from(keyCount),
        keys: keys.map(function (key) {
          return new PublicKey(key).toBuffer();
        }),
        recentBlockhash: Buffer.from(bs58.decode(recentBlockhash))
      };
      var signData = Buffer.alloc(2048);
      var length = signDataLayout.encode(transaction, signData);
      instructionBuffer.copy(signData, length);
      signData = signData.slice(0, length + instructionBuffer.length);
      return signData;
    }
    /**
     * Sign the Transaction with the specified accounts.  Multiple signatures may
     * be applied to a Transaction. The first signature is considered "primary"
     * and is used when testing for Transaction confirmation.
     *
     * Transaction fields should not be modified after the first call to `sign`,
     * as doing so may invalidate the signature and cause the Transaction to be
     * rejected.
     *
     * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
     */

  }, {
    key: "sign",
    value: function sign() {
      this.signPartial.apply(this, arguments);
    }
    /**
     * Partially sign a Transaction with the specified accounts.  The `Account`
     * inputs will be used to sign the Transaction immediately, while any
     * `PublicKey` inputs will be referenced in the signed Transaction but need to
     * be filled in later by calling `addSigner()` with the matching `Account`.
     *
     * All the caveats from the `sign` method apply to `signPartial`
     */

  }, {
    key: "signPartial",
    value: function signPartial() {
      for (var _len2 = arguments.length, partialSigners = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        partialSigners[_key2] = arguments[_key2];
      }

      if (partialSigners.length === 0) {
        throw new Error('No signers');
      }

      var signatures = partialSigners.map(function (accountOrPublicKey) {
        var publicKey = accountOrPublicKey instanceof Account ? accountOrPublicKey.publicKey : accountOrPublicKey;
        return {
          signature: null,
          publicKey: publicKey
        };
      });
      this.signatures = signatures;

      var signData = this._getSignData();

      partialSigners.forEach(function (accountOrPublicKey, index) {
        if (accountOrPublicKey instanceof PublicKey) {
          return;
        }

        var signature = nacl.sign.detached(signData, accountOrPublicKey.secretKey);
        assert(signature.length === 64);
        signatures[index].signature = Buffer.from(signature);
      });
    }
    /**
     * Fill in a signature for a partially signed Transaction.  The `signer` must
     * be the corresponding `Account` for a `PublicKey` that was previously provided to
     * `signPartial`
     */

  }, {
    key: "addSigner",
    value: function addSigner(signer) {
      var index = this.signatures.findIndex(function (sigpair) {
        return signer.publicKey.equals(sigpair.publicKey);
      });

      if (index < 0) {
        throw new Error("Unknown signer: ".concat(signer.publicKey.toString()));
      }

      var signData = this._getSignData();

      var signature = nacl.sign.detached(signData, signer.secretKey);
      assert(signature.length === 64);
      this.signatures[index].signature = Buffer.from(signature);
    }
    /**
     * Verify signatures of a complete, signed Transaction
     */

  }, {
    key: "verifySignatures",
    value: function verifySignatures() {
      var verified = true;

      var signData = this._getSignData();

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.signatures[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _step.value,
              signature = _step$value.signature,
              publicKey = _step$value.publicKey;

          if (!nacl.sign.detached.verify(signData, signature, publicKey.toBuffer())) {
            verified = false;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return verified;
    }
    /**
     * Serialize the Transaction in the wire format.
     *
     * The Transaction must have a valid `signature` before invoking this method
     */

  }, {
    key: "serialize",
    value: function serialize() {
      var signatures = this.signatures;

      if (!signatures) {
        throw new Error('Transaction has not been signed');
      }

      var signData = this._getSignData();

      var signatureCount = [];
      encodeLength(signatureCount, signatures.length);
      var transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
      var wireTransaction = Buffer.alloc(transactionLength);
      assert(signatures.length < 256);
      Buffer.from(signatureCount).copy(wireTransaction, 0);
      signatures.forEach(function (_ref2, index) {
        var signature = _ref2.signature;

        if (signature !== null) {
          assert(signature.length === 64, "signature has invalid length");
          Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);
        }
      });
      signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
      assert(wireTransaction.length <= PACKET_DATA_SIZE, "Transaction too large: ".concat(wireTransaction.length, " > ").concat(PACKET_DATA_SIZE));
      return wireTransaction;
    }
    /**
     * Deprecated method
     * @private
     */

  }, {
    key: "keys",
    get: function get() {
      assert(this.instructions.length === 1);
      return this.instructions[0].keys.map(function (keyObj) {
        return keyObj.pubkey;
      });
    }
    /**
     * Deprecated method
     * @private
     */

  }, {
    key: "programId",
    get: function get() {
      assert(this.instructions.length === 1);
      return this.instructions[0].programId;
    }
    /**
     * Deprecated method
     * @private
     */

  }, {
    key: "data",
    get: function get() {
      assert(this.instructions.length === 1);
      return this.instructions[0].data;
    }
    /**
     * Parse a wire transaction into a Transaction object.
     */

  }], [{
    key: "from",
    value: function from(buffer) {
      // Slice up wire data
      var byteArray = _toConsumableArray(buffer);

      var signatureCount = decodeLength(byteArray);
      var signatures = [];

      for (var i = 0; i < signatureCount; i++) {
        var signature = byteArray.slice(0, SIGNATURE_LENGTH);
        byteArray = byteArray.slice(SIGNATURE_LENGTH);
        signatures.push(bs58.encode(Buffer.from(signature)));
      }

      var numRequiredSignatures = byteArray.shift(); // byteArray = byteArray.slice(1); // Skip numRequiredSignatures byte

      var numReadonlySignedAccounts = byteArray.shift(); // byteArray = byteArray.slice(1); // Skip numReadonlySignedAccounts byte

      var numReadonlyUnsignedAccounts = byteArray.shift(); // byteArray = byteArray.slice(1); // Skip numReadonlyUnsignedAccounts byte

      var accountCount = decodeLength(byteArray);
      var accounts = [];

      for (var _i = 0; _i < accountCount; _i++) {
        var account = byteArray.slice(0, PUBKEY_LENGTH);
        byteArray = byteArray.slice(PUBKEY_LENGTH);
        accounts.push(bs58.encode(Buffer.from(account)));
      }

      var recentBlockhash = byteArray.slice(0, PUBKEY_LENGTH);
      byteArray = byteArray.slice(PUBKEY_LENGTH);
      var instructionCount = decodeLength(byteArray);
      var instructions = [];

      for (var _i2 = 0; _i2 < instructionCount; _i2++) {
        var instruction = {};
        instruction.programIndex = byteArray.shift();

        var _accountCount = decodeLength(byteArray);

        instruction.accounts = byteArray.slice(0, _accountCount);
        byteArray = byteArray.slice(_accountCount);
        var dataLength = decodeLength(byteArray);
        var data = byteArray.slice(0, dataLength);
        instruction.data = bs58.encode(Buffer.from(data));
        byteArray = byteArray.slice(dataLength);
        instructions.push(instruction);
      }

      return Transaction._populate(signatures, accounts, instructions, recentBlockhash, numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts);
    }
    /**
     * Parse an RPC result into a Transaction object.
     */

  }, {
    key: "fromRpcResult",
    value: function fromRpcResult(rpcResult) {
      var signatures = rpcResult.signatures;
      var accounts = rpcResult.message.accountKeys;
      var instructions = rpcResult.message.instructions;
      var recentBlockhash = rpcResult.message.recentBlockhash;
      var numRequiredSignatures = rpcResult.message.header.numRequiredSignatures;
      var numReadonlySignedAccounts = rpcResult.message.header.numReadonlySignedAccounts;
      var numReadonlyUnsignedAccounts = rpcResult.message.header.numReadonlyUnsignedAccounts;
      return Transaction._populate(signatures, accounts, instructions, recentBlockhash, numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts);
    }
    /**
     * Populate Transaction object
     * @private
     */

  }, {
    key: "_populate",
    value: function _populate(signatures, accounts, instructions, recentBlockhash, numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts) {
      function isWritable(i, numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts, numKeys) {
        return i < numRequiredSignatures - numReadonlySignedAccounts || i >= numRequiredSignatures && i < numKeys - numReadonlyUnsignedAccounts;
      }

      var transaction = new Transaction();
      transaction.recentBlockhash = new PublicKey(recentBlockhash).toBase58();

      for (var i = 0; i < signatures.length; i++) {
        var sigPubkeyPair = {
          signature: signatures[i] == bs58.encode(DEFAULT_SIGNATURE) ? null : bs58.decode(signatures[i]),
          publicKey: new PublicKey(accounts[i])
        };
        transaction.signatures.push(sigPubkeyPair);
      }

      for (var _i3 = 0; _i3 < instructions.length; _i3++) {
        var instructionData = {
          keys: [],
          programId: new PublicKey(accounts[instructions[_i3].programIndex]),
          data: bs58.decode(instructions[_i3].data)
        };

        var _loop = function _loop(j) {
          var pubkey = new PublicKey(accounts[instructions[_i3].accounts[j]]);
          instructionData.keys.push({
            pubkey: pubkey,
            isSigner: transaction.signatures.some(function (keyObj) {
              return keyObj.publicKey.toString() === pubkey.toString();
            }),
            isWritable: isWritable(j, numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts, accounts.length)
          });
        };

        for (var j = 0; j < instructions[_i3].accounts.length; j++) {
          _loop(j);
        }

        var instruction = new TransactionInstruction(instructionData);
        transaction.instructions.push(instruction);
      }

      return transaction;
    }
  }]);

  return Transaction;
}();

var SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');
var SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey('SysvarRecentB1ockHashes11111111111111111111');
var SYSVAR_RENT_PUBKEY = new PublicKey('SysvarRent111111111111111111111111111111111');
var SYSVAR_REWARDS_PUBKEY = new PublicKey('SysvarRewards111111111111111111111111111111');
var SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey('SysvarStakeHistory1111111111111111111111111');

/**
 * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11
 *
 * @private
 */

var FeeCalculatorLayout = nu64('lamportsPerSignature');
/**
 * @typedef {Object} FeeCalculator
 * @property {number} lamportsPerSignature lamports Cost in lamports to validate a signature
 */

/**
 * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32
 *
 * @private
 */

var NonceAccountLayout = struct([u32('version'), u32('state'), publicKey('authorizedPubkey'), publicKey('nonce'), struct([FeeCalculatorLayout], 'feeCalculator')]);
var NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
/**
 * NonceAccount class
 */

var NonceAccount = /*#__PURE__*/function () {
  function NonceAccount() {
    _classCallCheck(this, NonceAccount);

    _defineProperty(this, "authorizedPubkey", void 0);

    _defineProperty(this, "nonce", void 0);

    _defineProperty(this, "feeCalculator", void 0);
  }

  _createClass(NonceAccount, null, [{
    key: "fromAccountData",

    /**
     * Deserialize NonceAccount from the account data.
     *
     * @param buffer account data
     * @return NonceAccount
     */
    value: function fromAccountData(buffer) {
      var nonceAccount = NonceAccountLayout.decode(buffer, 0);
      nonceAccount.authorizedPubkey = new PublicKey(nonceAccount.authorizedPubkey);
      nonceAccount.nonce = new PublicKey(nonceAccount.nonce).toString();
      return nonceAccount;
    }
  }]);

  return NonceAccount;
}();

// zzz
function sleep(ms) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms);
  });
}

/**
 * @private
 */
function jsonRpcResultAndContext(resultDescription) {
  return jsonRpcResult({
    context: struct$1({
      slot: 'number'
    }),
    value: resultDescription
  });
}
/**
 * @private
 */


function jsonRpcResult(resultDescription) {
  var jsonRpcVersion = struct$1.literal('2.0');
  return struct$1.union([struct$1({
    jsonrpc: jsonRpcVersion,
    id: 'string',
    error: 'any'
  }), struct$1({
    jsonrpc: jsonRpcVersion,
    id: 'string',
    error: 'null?',
    result: resultDescription
  })]);
}
/**
 * The level of commitment desired when querying state
 *   'max':    Query the most recent block which has reached max voter lockout
 *   'recent': Query the most recent block
 *
 * @typedef {'max' | 'recent'} Commitment
 */


/**
 * Network Inflation parameters
 * (see https://docs.solana.com/book/v/master/implemented-proposals/ed_overview)
 *
 * @typedef {Object} Inflation
 * @property {number} foundation
 * @property {number} foundation_term
 * @property {number} initial
 * @property {number} storage
 * @property {number} taper
 * @property {number} terminal
 */
var GetInflationResult = struct$1({
  foundation: 'number',
  foundationTerm: 'number',
  initial: 'number',
  storage: 'number',
  taper: 'number',
  terminal: 'number'
});
/**
 * EpochInfo parameters
 * (see https://docs.solana.com/book/v/master/terminology#epoch)
 *
 * @typedef {Object} EpochInfo
 * @property {number} epoch
 * @property {number} slotIndex
 * @property {number} slotsInEpoch
 * @property {number} absoluteSlot
 */

var GetEpochInfoResult = struct$1({
  epoch: 'number',
  slotIndex: 'number',
  slotsInEpoch: 'number',
  absoluteSlot: 'number'
});
/**
 * EpochSchedule parameters
 * (see https://docs.solana.com/book/v/master/terminology#epoch)
 *
 * @typedef {Object} EpochSchedule
 * @property {number} slots_per_epoch
 * @property {number} leader_schedule_slot_offset
 * @property {boolean} warmup
 * @property {number} first_normal_epoch
 * @property {number} first_normal_slot
 */

var GetEpochScheduleResult = struct$1({
  slotsPerEpoch: 'number',
  leaderScheduleSlotOffset: 'number',
  warmup: 'boolean',
  firstNormalEpoch: 'number',
  firstNormalSlot: 'number'
});
/**
 * Signature status for a transaction
 */

var SignatureStatusResult = struct$1.union([struct$1({
  Ok: 'null'
}), struct$1({
  Err: 'object'
})]);
/**
 * Version info for a node
 *
 * @typedef {Object} Version
 * @property {string} solana-core Version of solana-core
 */

var Version = struct$1({
  'solana-core': 'string'
});
/**
 * A ConfirmedBlock on the ledger
 *
 * @typedef {Object} ConfirmedBlock
 * @property {Blockhash} blockhash Blockhash of this block
 * @property {Blockhash} previousBlockhash Blockhash of this block's parent
 * @property {number} parentSlot Slot index of this block's parent
 * @property {Array<object>} transactions Vector of transactions and status metas
 * @property {Array<object>} rewards Vector of block rewards
 */

function createRpcRequest(url) {
  var server = jayson( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(request, callback) {
      var options, res, text;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              options = {
                method: 'POST',
                body: request,
                headers: {
                  'Content-Type': 'application/json'
                }
              };
              _context.prev = 1;
              _context.next = 4;
              return fetch(url, options);

            case 4:
              res = _context.sent;
              _context.next = 7;
              return res.text();

            case 7:
              text = _context.sent;
              callback(null, text);
              _context.next = 14;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](1);
              callback(_context.t0);

            case 14:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[1, 11]]);
    }));

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }());
  return function (method, args) {
    return new Promise(function (resolve, reject) {
      server.request(method, args, function (err, response) {
        if (err) {
          reject(err);
          return;
        }

        resolve(response);
      });
    });
  };
}
/**
 * Expected JSON RPC response for the "getInflation" message
 */


var GetInflationRpcResult = struct$1({
  jsonrpc: struct$1.literal('2.0'),
  id: 'string',
  error: 'any?',
  result: GetInflationResult
});
/**
 * Expected JSON RPC response for the "getEpochInfo" message
 */

var GetEpochInfoRpcResult = struct$1({
  jsonrpc: struct$1.literal('2.0'),
  id: 'string',
  error: 'any?',
  result: GetEpochInfoResult
});
/**
 * Expected JSON RPC response for the "getEpochSchedule" message
 */

var GetEpochScheduleRpcResult = struct$1({
  jsonrpc: struct$1.literal('2.0'),
  id: 'string',
  error: 'any?',
  result: GetEpochScheduleResult
});
/**
 * Expected JSON RPC response for the "getBalance" message
 */

var GetBalanceAndContextRpcResult = jsonRpcResultAndContext('number?');
/**
 * Expected JSON RPC response for the "getVersion" message
 */

var GetVersionRpcResult = struct$1({
  jsonrpc: struct$1.literal('2.0'),
  id: 'string',
  error: 'any?',
  result: Version
});
/**
 * @private
 */

var AccountInfoResult = struct$1({
  executable: 'boolean',
  owner: 'string',
  lamports: 'number',
  data: 'string',
  rentEpoch: 'number?'
});
/**
 * Expected JSON RPC response for the "getAccountInfo" message
 */

var GetAccountInfoAndContextRpcResult = jsonRpcResultAndContext(struct$1.union(['null', AccountInfoResult]));
/***
 * Expected JSON RPC response for the "accountNotification" message
 */

var AccountNotificationResult = struct$1({
  subscription: 'number',
  result: AccountInfoResult
});
/**
 * @private
 */

var ProgramAccountInfoResult = struct$1({
  pubkey: 'string',
  account: AccountInfoResult
});
/***
 * Expected JSON RPC response for the "programNotification" message
 */

var ProgramAccountNotificationResult = struct$1({
  subscription: 'number',
  result: ProgramAccountInfoResult
});
/**
 * @private
 */

var SlotInfo = struct$1({
  parent: 'number',
  slot: 'number',
  root: 'number'
});
/**
 * Expected JSON RPC response for the "slotNotification" message
 */

var SlotNotificationResult = struct$1({
  subscription: 'number',
  result: SlotInfo
});
/**
 * Expected JSON RPC response for the "signatureNotification" message
 */

var SignatureNotificationResult = struct$1({
  subscription: 'number',
  result: SignatureStatusResult
});
/**
 * Expected JSON RPC response for the "getProgramAccounts" message
 */

var GetProgramAccountsRpcResult = jsonRpcResult(struct$1.array([ProgramAccountInfoResult]));
/**
 * Expected JSON RPC response for the "confirmTransaction" message
 */

var ConfirmTransactionAndContextRpcResult = jsonRpcResultAndContext('boolean');
/**
 * Expected JSON RPC response for the "getSlot" message
 */

var GetSlot = jsonRpcResult('number');
/**
 * Expected JSON RPC response for the "getSlotLeader" message
 */

var GetSlotLeader = jsonRpcResult('string');
/**
 * Expected JSON RPC response for the "getClusterNodes" message
 */

var GetClusterNodes = jsonRpcResult(struct$1.array([struct$1({
  pubkey: 'string',
  gossip: 'string',
  tpu: struct$1.union(['null', 'string']),
  rpc: struct$1.union(['null', 'string'])
})]));
/**
 * Expected JSON RPC response for the "getVoteAccounts" message
 */

var GetVoteAccounts = jsonRpcResult(struct$1({
  current: struct$1.array([struct$1({
    votePubkey: 'string',
    nodePubkey: 'string',
    activatedStake: 'number',
    epochVoteAccount: 'boolean',
    epochCredits: struct$1.array([struct$1.tuple(['number', 'number', 'number'])]),
    commission: 'number',
    lastVote: 'number',
    rootSlot: 'number?'
  })]),
  delinquent: struct$1.array([struct$1({
    votePubkey: 'string',
    nodePubkey: 'string',
    activatedStake: 'number',
    epochVoteAccount: 'boolean',
    epochCredits: struct$1.array([struct$1.tuple(['number', 'number', 'number'])]),
    commission: 'number',
    lastVote: 'number',
    rootSlot: 'number?'
  })])
}));
/**
 * Expected JSON RPC response for the "getSignatureStatus" message
 */

var GetSignatureStatusRpcResult = jsonRpcResult(struct$1.union(['null', SignatureStatusResult]));
/**
 * Expected JSON RPC response for the "getTransactionCount" message
 */

var GetTransactionCountRpcResult = jsonRpcResult('number');
/**
 * Expected JSON RPC response for the "getTotalSupply" message
 */

var GetTotalSupplyRpcResult = jsonRpcResult('number');
/**
 * Expected JSON RPC response for the "getMinimumBalanceForRentExemption" message
 */

var GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult('number');
/**
 * Expected JSON RPC response for the "getConfirmedBlock" message
 */

var GetConfirmedBlockRpcResult = jsonRpcResult(struct$1.union(['null', struct$1({
  blockhash: 'string',
  previousBlockhash: 'string',
  parentSlot: 'number',
  transactions: struct$1.array([struct$1({
    transaction: struct$1({
      signatures: struct$1.array(['string']),
      message: struct$1({
        accountKeys: struct$1.array(['string']),
        header: struct$1({
          numRequiredSignatures: 'number',
          numReadonlySignedAccounts: 'number',
          numReadonlyUnsignedAccounts: 'number'
        }),
        instructions: struct$1.array([struct$1.union([struct$1.array(['number']), struct$1({
          accounts: struct$1.array(['number']),
          data: 'string',
          programIdIndex: 'number'
        })])]),
        recentBlockhash: 'string'
      })
    }),
    meta: struct$1.union(['null', struct$1({
      status: struct$1.union(['null', SignatureStatusResult]),
      fee: 'number',
      preBalances: struct$1.array(['number']),
      postBalances: struct$1.array(['number'])
    })])
  })]),
  rewards: struct$1.union(['undefined', struct$1.array([struct$1({
    pubkey: 'string',
    lamports: 'number'
  })])])
})]));
/**
 * Expected JSON RPC response for the "getRecentBlockhash" message
 */

var GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(struct$1({
  blockhash: 'string',
  feeCalculator: struct$1({
    lamportsPerSignature: 'number'
  })
}));
/**
 * Expected JSON RPC response for the "requestAirdrop" message
 */

var RequestAirdropRpcResult = jsonRpcResult('string');
/**
 * Expected JSON RPC response for the "sendTransaction" message
 */

var SendTransactionRpcResult = jsonRpcResult('string');
/**
 * Information describing an account
 *
 * @typedef {Object} AccountInfo
 * @property {number} lamports Number of lamports assigned to the account
 * @property {PublicKey} owner Identifier of the program that owns the account
 * @property {?Buffer} data Optional data assigned to the account
 * @property {boolean} executable `true` if this account's data contains a loaded program
 */

/**
 * A connection to a fullnode JSON RPC endpoint
 */
var Connection = /*#__PURE__*/function () {
  /**
   * Establish a JSON RPC connection
   *
   * @param endpoint URL to the fullnode JSON RPC endpoint
   * @param commitment optional default commitment level
   */
  function Connection(endpoint, commitment) {
    _classCallCheck(this, Connection);

    _defineProperty(this, "_rpcRequest", void 0);

    _defineProperty(this, "_rpcWebSocket", void 0);

    _defineProperty(this, "_rpcWebSocketConnected", false);

    _defineProperty(this, "_commitment", void 0);

    _defineProperty(this, "_blockhashInfo", void 0);

    _defineProperty(this, "_disableBlockhashCaching", false);

    _defineProperty(this, "_accountChangeSubscriptions", {});

    _defineProperty(this, "_accountChangeSubscriptionCounter", 0);

    _defineProperty(this, "_programAccountChangeSubscriptions", {});

    _defineProperty(this, "_programAccountChangeSubscriptionCounter", 0);

    _defineProperty(this, "_slotSubscriptions", {});

    _defineProperty(this, "_slotSubscriptionCounter", 0);

    _defineProperty(this, "_signatureSubscriptions", {});

    _defineProperty(this, "_signatureSubscriptionCounter", 0);

    var url = parse(endpoint);
    this._rpcRequest = createRpcRequest(url.href);
    this._commitment = commitment;
    this._blockhashInfo = {
      recentBlockhash: null,
      seconds: -1,
      transactionSignatures: []
    };
    url.protocol = url.protocol === 'https:' ? 'wss:' : 'ws:';
    url.host = '';
    url.port = String(Number(url.port) + 1);

    if (url.port === '1') {
      url.port = url.protocol === 'wss:' ? '8901' : '8900';
    }

    this._rpcWebSocket = new Client(format(url), {
      autoconnect: false,
      max_reconnects: Infinity
    });

    this._rpcWebSocket.on('open', this._wsOnOpen.bind(this));

    this._rpcWebSocket.on('error', this._wsOnError.bind(this));

    this._rpcWebSocket.on('close', this._wsOnClose.bind(this));

    this._rpcWebSocket.on('accountNotification', this._wsOnAccountNotification.bind(this));

    this._rpcWebSocket.on('programNotification', this._wsOnProgramAccountNotification.bind(this));

    this._rpcWebSocket.on('slotNotification', this._wsOnSlotNotification.bind(this));

    this._rpcWebSocket.on('signatureNotification', this._wsOnSignatureNotification.bind(this));
  }
  /**
   * Fetch the balance for the specified public key, return with context
   */


  _createClass(Connection, [{
    key: "getBalanceAndContext",
    value: function () {
      var _getBalanceAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(publicKey, commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                args = this._argsWithCommitment([publicKey.toBase58()], commitment);
                _context2.next = 3;
                return this._rpcRequest('getBalance', args);

              case 3:
                unsafeRes = _context2.sent;
                res = GetBalanceAndContextRpcResult(unsafeRes);

                if (!res.error) {
                  _context2.next = 7;
                  break;
                }

                throw new Error(res.error.message);

              case 7:
                assert(typeof res.result !== 'undefined');
                return _context2.abrupt("return", res.result);

              case 9:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getBalanceAndContext(_x3, _x4) {
        return _getBalanceAndContext.apply(this, arguments);
      }

      return getBalanceAndContext;
    }()
    /**
     * Fetch the balance for the specified public key
     */

  }, {
    key: "getBalance",
    value: function () {
      var _getBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(publicKey, commitment) {
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getBalanceAndContext(publicKey, commitment).then(function (x) {
                  return x.value;
                })["catch"](function (e) {
                  throw e;
                });

              case 2:
                return _context3.abrupt("return", _context3.sent);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getBalance(_x5, _x6) {
        return _getBalance.apply(this, arguments);
      }

      return getBalance;
    }()
    /**
     * Fetch all the account info for the specified public key, return with context
     */

  }, {
    key: "getAccountInfoAndContext",
    value: function () {
      var _getAccountInfoAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(publicKey, commitment) {
        var args, unsafeRes, res, _res$result$value, executable, owner, lamports, data, value;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                args = this._argsWithCommitment([publicKey.toBase58()], commitment);
                _context4.next = 3;
                return this._rpcRequest('getAccountInfo', args);

              case 3:
                unsafeRes = _context4.sent;
                res = GetAccountInfoAndContextRpcResult(unsafeRes);

                if (!res.error) {
                  _context4.next = 7;
                  break;
                }

                throw new Error(res.error.message);

              case 7:
                assert(typeof res.result !== 'undefined');

                if (res.result.value) {
                  _context4.next = 10;
                  break;
                }

                throw new Error('Invalid request');

              case 10:
                _res$result$value = res.result.value, executable = _res$result$value.executable, owner = _res$result$value.owner, lamports = _res$result$value.lamports, data = _res$result$value.data;
                value = {
                  executable: executable,
                  owner: new PublicKey(owner),
                  lamports: lamports,
                  data: bs58.decode(data)
                };
                return _context4.abrupt("return", {
                  context: {
                    slot: res.result.context.slot
                  },
                  value: value
                });

              case 13:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getAccountInfoAndContext(_x7, _x8) {
        return _getAccountInfoAndContext.apply(this, arguments);
      }

      return getAccountInfoAndContext;
    }()
    /**
     * Fetch all the account info for the specified public key
     */

  }, {
    key: "getAccountInfo",
    value: function () {
      var _getAccountInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(publicKey, commitment) {
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.getAccountInfoAndContext(publicKey, commitment).then(function (x) {
                  return x.value;
                })["catch"](function (e) {
                  throw e;
                });

              case 2:
                return _context5.abrupt("return", _context5.sent);

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getAccountInfo(_x9, _x10) {
        return _getAccountInfo.apply(this, arguments);
      }

      return getAccountInfo;
    }()
    /**
     * Fetch all the accounts owned by the specified program id
     *
     * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo}>>}
     */

  }, {
    key: "getProgramAccounts",
    value: function () {
      var _getProgramAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(programId, commitment) {
        var args, unsafeRes, res, result;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                args = this._argsWithCommitment([programId.toBase58()], commitment);
                _context6.next = 3;
                return this._rpcRequest('getProgramAccounts', args);

              case 3:
                unsafeRes = _context6.sent;
                res = GetProgramAccountsRpcResult(unsafeRes);

                if (!res.error) {
                  _context6.next = 7;
                  break;
                }

                throw new Error(res.error.message);

              case 7:
                result = res.result;
                assert(typeof result !== 'undefined');
                return _context6.abrupt("return", result.map(function (result) {
                  return {
                    pubkey: result.pubkey,
                    account: {
                      executable: result.account.executable,
                      owner: new PublicKey(result.account.owner),
                      lamports: result.account.lamports,
                      data: bs58.decode(result.account.data)
                    }
                  };
                }));

              case 10:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getProgramAccounts(_x11, _x12) {
        return _getProgramAccounts.apply(this, arguments);
      }

      return getProgramAccounts;
    }()
    /**
     * Confirm the transaction identified by the specified signature, return with context
     */

  }, {
    key: "confirmTransactionAndContext",
    value: function () {
      var _confirmTransactionAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(signature, commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                args = this._argsWithCommitment([signature], commitment);
                _context7.next = 3;
                return this._rpcRequest('confirmTransaction', args);

              case 3:
                unsafeRes = _context7.sent;
                res = ConfirmTransactionAndContextRpcResult(unsafeRes);

                if (!res.error) {
                  _context7.next = 7;
                  break;
                }

                throw new Error(res.error.message);

              case 7:
                assert(typeof res.result !== 'undefined');
                return _context7.abrupt("return", res.result);

              case 9:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function confirmTransactionAndContext(_x13, _x14) {
        return _confirmTransactionAndContext.apply(this, arguments);
      }

      return confirmTransactionAndContext;
    }()
    /**
     * Confirm the transaction identified by the specified signature
     */

  }, {
    key: "confirmTransaction",
    value: function () {
      var _confirmTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(signature, commitment) {
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.confirmTransactionAndContext(signature, commitment).then(function (x) {
                  return x.value;
                })["catch"](function (e) {
                  throw e;
                });

              case 2:
                return _context8.abrupt("return", _context8.sent);

              case 3:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function confirmTransaction(_x15, _x16) {
        return _confirmTransaction.apply(this, arguments);
      }

      return confirmTransaction;
    }()
    /**
     * Return the list of nodes that are currently participating in the cluster
     */

  }, {
    key: "getClusterNodes",
    value: function () {
      var _getClusterNodes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {
        var unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this._rpcRequest('getClusterNodes', []);

              case 2:
                unsafeRes = _context9.sent;
                res = GetClusterNodes(unsafeRes);

                if (!res.error) {
                  _context9.next = 6;
                  break;
                }

                throw new Error(res.error.message);

              case 6:
                assert(typeof res.result !== 'undefined');
                return _context9.abrupt("return", res.result);

              case 8:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getClusterNodes() {
        return _getClusterNodes.apply(this, arguments);
      }

      return getClusterNodes;
    }()
    /**
     * Return the list of nodes that are currently participating in the cluster
     */

  }, {
    key: "getVoteAccounts",
    value: function () {
      var _getVoteAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                args = this._argsWithCommitment([], commitment);
                _context10.next = 3;
                return this._rpcRequest('getVoteAccounts', args);

              case 3:
                unsafeRes = _context10.sent;
                res = GetVoteAccounts(unsafeRes); //const res = unsafeRes;

                if (!res.error) {
                  _context10.next = 7;
                  break;
                }

                throw new Error(res.error.message);

              case 7:
                assert(typeof res.result !== 'undefined');
                return _context10.abrupt("return", res.result);

              case 9:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getVoteAccounts(_x17) {
        return _getVoteAccounts.apply(this, arguments);
      }

      return getVoteAccounts;
    }()
    /**
     * Fetch the current slot that the node is processing
     */

  }, {
    key: "getSlot",
    value: function () {
      var _getSlot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                args = this._argsWithCommitment([], commitment);
                _context11.next = 3;
                return this._rpcRequest('getSlot', args);

              case 3:
                unsafeRes = _context11.sent;
                res = GetSlot(unsafeRes);

                if (!res.error) {
                  _context11.next = 7;
                  break;
                }

                throw new Error(res.error.message);

              case 7:
                assert(typeof res.result !== 'undefined');
                return _context11.abrupt("return", res.result);

              case 9:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getSlot(_x18) {
        return _getSlot.apply(this, arguments);
      }

      return getSlot;
    }()
    /**
     * Fetch the current slot leader of the cluster
     */

  }, {
    key: "getSlotLeader",
    value: function () {
      var _getSlotLeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                args = this._argsWithCommitment([], commitment);
                _context12.next = 3;
                return this._rpcRequest('getSlotLeader', args);

              case 3:
                unsafeRes = _context12.sent;
                res = GetSlotLeader(unsafeRes);

                if (!res.error) {
                  _context12.next = 7;
                  break;
                }

                throw new Error(res.error.message);

              case 7:
                assert(typeof res.result !== 'undefined');
                return _context12.abrupt("return", res.result);

              case 9:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getSlotLeader(_x19) {
        return _getSlotLeader.apply(this, arguments);
      }

      return getSlotLeader;
    }()
    /**
     * Fetch the current status of a signature
     */

  }, {
    key: "getSignatureStatus",
    value: function () {
      var _getSignatureStatus = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(signature, commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                args = this._argsWithCommitment([signature], commitment);
                _context13.next = 3;
                return this._rpcRequest('getSignatureStatus', args);

              case 3:
                unsafeRes = _context13.sent;
                res = GetSignatureStatusRpcResult(unsafeRes);

                if (!res.error) {
                  _context13.next = 7;
                  break;
                }

                throw new Error(res.error.message);

              case 7:
                assert(typeof res.result !== 'undefined');
                return _context13.abrupt("return", res.result);

              case 9:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getSignatureStatus(_x20, _x21) {
        return _getSignatureStatus.apply(this, arguments);
      }

      return getSignatureStatus;
    }()
    /**
     * Fetch the current transaction count of the cluster
     */

  }, {
    key: "getTransactionCount",
    value: function () {
      var _getTransactionCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                args = this._argsWithCommitment([], commitment);
                _context14.next = 3;
                return this._rpcRequest('getTransactionCount', args);

              case 3:
                unsafeRes = _context14.sent;
                res = GetTransactionCountRpcResult(unsafeRes);

                if (!res.error) {
                  _context14.next = 7;
                  break;
                }

                throw new Error(res.error.message);

              case 7:
                assert(typeof res.result !== 'undefined');
                return _context14.abrupt("return", Number(res.result));

              case 9:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getTransactionCount(_x22) {
        return _getTransactionCount.apply(this, arguments);
      }

      return getTransactionCount;
    }()
    /**
     * Fetch the current total currency supply of the cluster in lamports
     */

  }, {
    key: "getTotalSupply",
    value: function () {
      var _getTotalSupply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                args = this._argsWithCommitment([], commitment);
                _context15.next = 3;
                return this._rpcRequest('getTotalSupply', args);

              case 3:
                unsafeRes = _context15.sent;
                res = GetTotalSupplyRpcResult(unsafeRes);

                if (!res.error) {
                  _context15.next = 7;
                  break;
                }

                throw new Error(res.error.message);

              case 7:
                assert(typeof res.result !== 'undefined');
                return _context15.abrupt("return", Number(res.result));

              case 9:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function getTotalSupply(_x23) {
        return _getTotalSupply.apply(this, arguments);
      }

      return getTotalSupply;
    }()
    /**
     * Fetch the cluster Inflation parameters
     */

  }, {
    key: "getInflation",
    value: function () {
      var _getInflation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                args = this._argsWithCommitment([], commitment);
                _context16.next = 3;
                return this._rpcRequest('getInflation', args);

              case 3:
                unsafeRes = _context16.sent;
                res = GetInflationRpcResult(unsafeRes);

                if (!res.error) {
                  _context16.next = 7;
                  break;
                }

                throw new Error(res.error.message);

              case 7:
                assert(typeof res.result !== 'undefined');
                return _context16.abrupt("return", GetInflationResult(res.result));

              case 9:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function getInflation(_x24) {
        return _getInflation.apply(this, arguments);
      }

      return getInflation;
    }()
    /**
     * Fetch the Epoch Info parameters
     */

  }, {
    key: "getEpochInfo",
    value: function () {
      var _getEpochInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                args = this._argsWithCommitment([], commitment);
                _context17.next = 3;
                return this._rpcRequest('getEpochInfo', args);

              case 3:
                unsafeRes = _context17.sent;
                res = GetEpochInfoRpcResult(unsafeRes);

                if (!res.error) {
                  _context17.next = 7;
                  break;
                }

                throw new Error(res.error.message);

              case 7:
                assert(typeof res.result !== 'undefined');
                return _context17.abrupt("return", GetEpochInfoResult(res.result));

              case 9:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function getEpochInfo(_x25) {
        return _getEpochInfo.apply(this, arguments);
      }

      return getEpochInfo;
    }()
    /**
     * Fetch the Epoch Schedule parameters
     */

  }, {
    key: "getEpochSchedule",
    value: function () {
      var _getEpochSchedule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18() {
        var unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this._rpcRequest('getEpochSchedule', []);

              case 2:
                unsafeRes = _context18.sent;
                res = GetEpochScheduleRpcResult(unsafeRes);

                if (!res.error) {
                  _context18.next = 6;
                  break;
                }

                throw new Error(res.error.message);

              case 6:
                assert(typeof res.result !== 'undefined');
                return _context18.abrupt("return", GetEpochScheduleResult(res.result));

              case 8:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getEpochSchedule() {
        return _getEpochSchedule.apply(this, arguments);
      }

      return getEpochSchedule;
    }()
    /**
     * Fetch the minimum balance needed to exempt an account of `dataLength`
     * size from rent
     */

  }, {
    key: "getMinimumBalanceForRentExemption",
    value: function () {
      var _getMinimumBalanceForRentExemption = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(dataLength, commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                args = this._argsWithCommitment([dataLength], commitment);
                _context19.next = 3;
                return this._rpcRequest('getMinimumBalanceForRentExemption', args);

              case 3:
                unsafeRes = _context19.sent;
                res = GetMinimumBalanceForRentExemptionRpcResult(unsafeRes);

                if (!res.error) {
                  _context19.next = 8;
                  break;
                }

                console.warn('Unable to fetch minimum balance for rent exemption');
                return _context19.abrupt("return", 0);

              case 8:
                assert(typeof res.result !== 'undefined');
                return _context19.abrupt("return", Number(res.result));

              case 10:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getMinimumBalanceForRentExemption(_x26, _x27) {
        return _getMinimumBalanceForRentExemption.apply(this, arguments);
      }

      return getMinimumBalanceForRentExemption;
    }()
    /**
     * Fetch a recent blockhash from the cluster, return with context
     * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
     */

  }, {
    key: "getRecentBlockhashAndContext",
    value: function () {
      var _getRecentBlockhashAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                args = this._argsWithCommitment([], commitment);
                _context20.next = 3;
                return this._rpcRequest('getRecentBlockhash', args);

              case 3:
                unsafeRes = _context20.sent;
                res = GetRecentBlockhashAndContextRpcResult(unsafeRes);

                if (!res.error) {
                  _context20.next = 7;
                  break;
                }

                throw new Error(res.error.message);

              case 7:
                assert(typeof res.result !== 'undefined');
                return _context20.abrupt("return", res.result);

              case 9:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getRecentBlockhashAndContext(_x28) {
        return _getRecentBlockhashAndContext.apply(this, arguments);
      }

      return getRecentBlockhashAndContext;
    }()
    /**
     * Fetch a recent blockhash from the cluster
     * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
     */

  }, {
    key: "getRecentBlockhash",
    value: function () {
      var _getRecentBlockhash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21(commitment) {
        return _regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return this.getRecentBlockhashAndContext(commitment).then(function (x) {
                  return x.value;
                })["catch"](function (e) {
                  throw e;
                });

              case 2:
                return _context21.abrupt("return", _context21.sent);

              case 3:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getRecentBlockhash(_x29) {
        return _getRecentBlockhash.apply(this, arguments);
      }

      return getRecentBlockhash;
    }()
    /**
     * Fetch the node version
     */

  }, {
    key: "getVersion",
    value: function () {
      var _getVersion = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22() {
        var unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this._rpcRequest('getVersion', []);

              case 2:
                unsafeRes = _context22.sent;
                res = GetVersionRpcResult(unsafeRes);

                if (!res.error) {
                  _context22.next = 6;
                  break;
                }

                throw new Error(res.error.message);

              case 6:
                assert(typeof res.result !== 'undefined');
                return _context22.abrupt("return", res.result);

              case 8:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getVersion() {
        return _getVersion.apply(this, arguments);
      }

      return getVersion;
    }()
    /**
     * Fetch a list of Transactions and transaction statuses from the cluster
     * for a confirmed block
     */

  }, {
    key: "getConfirmedBlock",
    value: function () {
      var _getConfirmedBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23(slot) {
        var unsafeRes, result;
        return _regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this._rpcRequest('getConfirmedBlock', [slot]);

              case 2:
                unsafeRes = _context23.sent;
                result = GetConfirmedBlockRpcResult(unsafeRes);

                if (!result.error) {
                  _context23.next = 6;
                  break;
                }

                throw new Error(result.error.message);

              case 6:
                assert(typeof result.result !== 'undefined');

                if (result.result) {
                  _context23.next = 9;
                  break;
                }

                throw new Error('Confirmed block ' + slot + ' not found');

              case 9:
                return _context23.abrupt("return", {
                  blockhash: new PublicKey(result.result.blockhash).toString(),
                  previousBlockhash: new PublicKey(result.result.previousBlockhash).toString(),
                  parentSlot: result.result.parentSlot,
                  transactions: result.result.transactions.map(function (result) {
                    return {
                      transaction: Transaction.fromRpcResult(result.transaction),
                      meta: result.meta
                    };
                  }),
                  rewards: result.result.rewards || []
                });

              case 10:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getConfirmedBlock(_x30) {
        return _getConfirmedBlock.apply(this, arguments);
      }

      return getConfirmedBlock;
    }()
    /**
     * Fetch the contents of a Nonce account from the cluster, return with context
     */

  }, {
    key: "getNonceAndContext",
    value: function () {
      var _getNonceAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee24(nonceAccount, commitment) {
        var args, unsafeRes, res, value;
        return _regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                args = this._argsWithCommitment([nonceAccount.toBase58()], commitment);
                _context24.next = 3;
                return this._rpcRequest('getAccountInfo', args);

              case 3:
                unsafeRes = _context24.sent;
                res = GetAccountInfoAndContextRpcResult(unsafeRes);

                if (!res.error) {
                  _context24.next = 7;
                  break;
                }

                throw new Error(res.error.message);

              case 7:
                assert(typeof res.result !== 'undefined');

                if (res.result.value) {
                  _context24.next = 10;
                  break;
                }

                throw new Error('Invalid request');

              case 10:
                value = NonceAccount.fromAccountData(bs58.decode(res.result.value.data));
                return _context24.abrupt("return", {
                  context: {
                    slot: res.result.context.slot
                  },
                  value: value
                });

              case 12:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getNonceAndContext(_x31, _x32) {
        return _getNonceAndContext.apply(this, arguments);
      }

      return getNonceAndContext;
    }()
    /**
     * Fetch the contents of a Nonce account from the cluster
     */

  }, {
    key: "getNonce",
    value: function () {
      var _getNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee25(nonceAccount, commitment) {
        return _regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return this.getNonceAndContext(nonceAccount, commitment).then(function (x) {
                  return x.value;
                })["catch"](function (e) {
                  throw e;
                });

              case 2:
                return _context25.abrupt("return", _context25.sent);

              case 3:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function getNonce(_x33, _x34) {
        return _getNonce.apply(this, arguments);
      }

      return getNonce;
    }()
    /**
     * Request an allocation of lamports to the specified account
     */

  }, {
    key: "requestAirdrop",
    value: function () {
      var _requestAirdrop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee26(to, amount, commitment) {
        var args, unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                args = this._argsWithCommitment([to.toBase58(), amount], commitment);
                _context26.next = 3;
                return this._rpcRequest('requestAirdrop', args);

              case 3:
                unsafeRes = _context26.sent;
                res = RequestAirdropRpcResult(unsafeRes);

                if (!res.error) {
                  _context26.next = 7;
                  break;
                }

                throw new Error(res.error.message);

              case 7:
                assert(typeof res.result !== 'undefined');
                return _context26.abrupt("return", res.result);

              case 9:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function requestAirdrop(_x35, _x36, _x37) {
        return _requestAirdrop.apply(this, arguments);
      }

      return requestAirdrop;
    }()
    /**
     * Sign and send a transaction
     */

  }, {
    key: "sendTransaction",
    value: function () {
      var _sendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee27(transaction) {
        var _len,
            signers,
            _key,
            seconds,
            signature,
            attempts,
            startTime,
            _ref2,
            blockhash,
            wireTransaction,
            _args27 = arguments;

        return _regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                for (_len = _args27.length, signers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  signers[_key - 1] = _args27[_key];
                }

                if (!transaction.nonceInfo) {
                  _context27.next = 5;
                  break;
                }

                transaction.sign.apply(transaction, signers);
                _context27.next = 34;
                break;

              case 5:
                // Attempt to use a recent blockhash for up to 30 seconds
                seconds = new Date().getSeconds();

                if (!(this._blockhashInfo.recentBlockhash != null && this._blockhashInfo.seconds < seconds + 30)) {
                  _context27.next = 16;
                  break;
                }

                transaction.recentBlockhash = this._blockhashInfo.recentBlockhash;
                transaction.sign.apply(transaction, signers);

                if (transaction.signature) {
                  _context27.next = 11;
                  break;
                }

                throw new Error('!signature');

              case 11:
                // If the signature of this transaction has not been seen before with the
                // current recentBlockhash, all done.
                signature = transaction.signature.toString();

                if (this._blockhashInfo.transactionSignatures.includes(signature)) {
                  _context27.next = 16;
                  break;
                }

                this._blockhashInfo.transactionSignatures.push(signature);

                if (this._disableBlockhashCaching) {
                  this._blockhashInfo.seconds = -1;
                }

                return _context27.abrupt("break", 34);

              case 16:
                // Fetch a new blockhash
                attempts = 0;
                startTime = Date.now();

              case 18:
                _context27.next = 20;
                return this.getRecentBlockhash();

              case 20:
                _ref2 = _context27.sent;
                blockhash = _ref2.blockhash;

                if (!(this._blockhashInfo.recentBlockhash != blockhash)) {
                  _context27.next = 25;
                  break;
                }

                this._blockhashInfo = {
                  recentBlockhash: blockhash,
                  seconds: new Date().getSeconds(),
                  transactionSignatures: []
                };
                return _context27.abrupt("break", 32);

              case 25:
                if (!(attempts === 50)) {
                  _context27.next = 27;
                  break;
                }

                throw new Error("Unable to obtain a new blockhash after ".concat(Date.now() - startTime, "ms"));

              case 27:
                _context27.next = 29;
                return sleep(500 * DEFAULT_TICKS_PER_SLOT / NUM_TICKS_PER_SECOND);

              case 29:
                ++attempts;

              case 30:
                _context27.next = 18;
                break;

              case 32:
                _context27.next = 5;
                break;

              case 34:
                wireTransaction = transaction.serialize();
                _context27.next = 37;
                return this.sendRawTransaction(wireTransaction);

              case 37:
                return _context27.abrupt("return", _context27.sent);

              case 38:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function sendTransaction(_x38) {
        return _sendTransaction.apply(this, arguments);
      }

      return sendTransaction;
    }()
    /**
     * @private
     */

  }, {
    key: "validatorExit",
    value: function () {
      var _validatorExit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee28() {
        var unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return this._rpcRequest('validatorExit', []);

              case 2:
                unsafeRes = _context28.sent;
                res = jsonRpcResult('boolean')(unsafeRes);

                if (!res.error) {
                  _context28.next = 6;
                  break;
                }

                throw new Error(res.error.message);

              case 6:
                assert(typeof res.result !== 'undefined');
                return _context28.abrupt("return", res.result);

              case 8:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function validatorExit() {
        return _validatorExit.apply(this, arguments);
      }

      return validatorExit;
    }()
    /**
     * Send a transaction that has already been signed and serialized into the
     * wire format
     */

  }, {
    key: "sendRawTransaction",
    value: function () {
      var _sendRawTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee29(rawTransaction) {
        var encodedTransaction, result;
        return _regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                encodedTransaction = bs58.encode(toBuffer(rawTransaction));
                _context29.next = 3;
                return this.sendEncodedTransaction(encodedTransaction);

              case 3:
                result = _context29.sent;
                return _context29.abrupt("return", result);

              case 5:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function sendRawTransaction(_x39) {
        return _sendRawTransaction.apply(this, arguments);
      }

      return sendRawTransaction;
    }()
    /**
     * Send a transaction that has already been signed, serialized into the
     * wire format, and encoded as a base58 string
     */

  }, {
    key: "sendEncodedTransaction",
    value: function () {
      var _sendEncodedTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee30(encodedTransaction) {
        var unsafeRes, res;
        return _regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _context30.next = 2;
                return this._rpcRequest('sendTransaction', [encodedTransaction]);

              case 2:
                unsafeRes = _context30.sent;
                res = SendTransactionRpcResult(unsafeRes);

                if (!res.error) {
                  _context30.next = 6;
                  break;
                }

                throw new Error(res.error.message);

              case 6:
                assert(typeof res.result !== 'undefined');
                assert(res.result);
                return _context30.abrupt("return", res.result);

              case 9:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function sendEncodedTransaction(_x40) {
        return _sendEncodedTransaction.apply(this, arguments);
      }

      return sendEncodedTransaction;
    }()
    /**
     * @private
     */

  }, {
    key: "_wsOnOpen",
    value: function _wsOnOpen() {
      this._rpcWebSocketConnected = true;

      this._updateSubscriptions();
    }
    /**
     * @private
     */

  }, {
    key: "_wsOnError",
    value: function _wsOnError(err) {
      console.log('ws error:', err.message);
    }
    /**
     * @private
     */

  }, {
    key: "_wsOnClose",
    value: function _wsOnClose(code, message) {
      // 1000 means _rpcWebSocket.close() was called explicitly
      if (code !== 1000) {
        console.log('ws close:', code, message);
      } else {
        // Only after an explicit close do we need to explicitly connect again
        this._rpcWebSocketConnected = false;
      }
    }
    /**
     * @private
     */

  }, {
    key: "_subscribe",
    value: function () {
      var _subscribe2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee31(sub, rpcMethod, rpcArgs) {
        var id;
        return _regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                if (!(sub.subscriptionId == null)) {
                  _context31.next = 13;
                  break;
                }

                sub.subscriptionId = 'subscribing';
                _context31.prev = 2;
                _context31.next = 5;
                return this._rpcWebSocket.call(rpcMethod, rpcArgs);

              case 5:
                id = _context31.sent;

                if (sub.subscriptionId === 'subscribing') {
                  // eslint-disable-next-line require-atomic-updates
                  sub.subscriptionId = id;
                }

                _context31.next = 13;
                break;

              case 9:
                _context31.prev = 9;
                _context31.t0 = _context31["catch"](2);

                if (sub.subscriptionId === 'subscribing') {
                  // eslint-disable-next-line require-atomic-updates
                  sub.subscriptionId = null;
                }

                console.error("".concat(rpcMethod, " error for argument"), rpcArgs, _context31.t0.message);

              case 13:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this, [[2, 9]]);
      }));

      function _subscribe(_x41, _x42, _x43) {
        return _subscribe2.apply(this, arguments);
      }

      return _subscribe;
    }()
    /**
     * @private
     */

  }, {
    key: "_unsubscribe",
    value: function () {
      var _unsubscribe2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee32(sub, rpcMethod) {
        var subscriptionId, unsubscribeId;
        return _regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                subscriptionId = sub.subscriptionId;

                if (!(subscriptionId != null && typeof subscriptionId != 'string')) {
                  _context32.next = 11;
                  break;
                }

                unsubscribeId = subscriptionId;
                _context32.prev = 3;
                _context32.next = 6;
                return this._rpcWebSocket.call(rpcMethod, [unsubscribeId]);

              case 6:
                _context32.next = 11;
                break;

              case 8:
                _context32.prev = 8;
                _context32.t0 = _context32["catch"](3);
                console.log("".concat(rpcMethod, " error:"), _context32.t0.message);

              case 11:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this, [[3, 8]]);
      }));

      function _unsubscribe(_x44, _x45) {
        return _unsubscribe2.apply(this, arguments);
      }

      return _unsubscribe;
    }()
    /**
     * @private
     */

  }, {
    key: "_updateSubscriptions",
    value: function _updateSubscriptions() {
      var accountKeys = Object.keys(this._accountChangeSubscriptions).map(Number);
      var programKeys = Object.keys(this._programAccountChangeSubscriptions).map(Number);
      var slotKeys = Object.keys(this._slotSubscriptions).map(Number);
      var signatureKeys = Object.keys(this._signatureSubscriptions).map(Number);

      if (accountKeys.length === 0 && programKeys.length === 0 && slotKeys.length === 0 && signatureKeys.length === 0) {
        this._rpcWebSocket.close();

        return;
      }

      if (!this._rpcWebSocketConnected) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = accountKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var id = _step.value;
            this._accountChangeSubscriptions[id].subscriptionId = null;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = programKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _id = _step2.value;
            this._programAccountChangeSubscriptions[_id].subscriptionId = null;
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = slotKeys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _id2 = _step3.value;
            this._slotSubscriptions[_id2].subscriptionId = null;
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = signatureKeys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var _id3 = _step4.value;
            this._signatureSubscriptions[_id3].subscriptionId = null;
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        this._rpcWebSocket.connect();

        return;
      }

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = accountKeys[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _id4 = _step5.value;
          var sub = this._accountChangeSubscriptions[_id4];

          this._subscribe(sub, 'accountSubscribe', [sub.publicKey]);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = programKeys[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var _id5 = _step6.value;
          var _sub = this._programAccountChangeSubscriptions[_id5];

          this._subscribe(_sub, 'programSubscribe', [_sub.programId]);
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = slotKeys[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var _id6 = _step7.value;
          var _sub2 = this._slotSubscriptions[_id6];

          this._subscribe(_sub2, 'slotSubscribe', []);
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
            _iterator7["return"]();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = signatureKeys[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var _id7 = _step8.value;
          var _sub3 = this._signatureSubscriptions[_id7];

          this._subscribe(_sub3, 'signatureSubscribe', [_sub3.signature]);
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
            _iterator8["return"]();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
    }
    /**
     * @private
     */

  }, {
    key: "_wsOnAccountNotification",
    value: function _wsOnAccountNotification(notification) {
      var res = AccountNotificationResult(notification);

      if (res.error) {
        throw new Error(res.error.message);
      }

      var keys = Object.keys(this._accountChangeSubscriptions).map(Number);
      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        for (var _iterator9 = keys[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          var id = _step9.value;
          var sub = this._accountChangeSubscriptions[id];

          if (sub.subscriptionId === res.subscription) {
            var result = res.result;
            assert(typeof result !== 'undefined');
            sub.callback({
              executable: result.executable,
              owner: new PublicKey(result.owner),
              lamports: result.lamports,
              data: bs58.decode(result.data)
            });
            return true;
          }
        }
      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
            _iterator9["return"]();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }
    }
    /**
     * Register a callback to be invoked whenever the specified account changes
     *
     * @param publickey Public key of the account to monitor
     * @param callback Function to invoke whenever the account is changed
     * @return subscription id
     */

  }, {
    key: "onAccountChange",
    value: function onAccountChange(publicKey, callback) {
      var id = ++this._accountChangeSubscriptionCounter;
      this._accountChangeSubscriptions[id] = {
        publicKey: publicKey.toBase58(),
        callback: callback,
        subscriptionId: null
      };

      this._updateSubscriptions();

      return id;
    }
    /**
     * Deregister an account notification callback
     *
     * @param id subscription id to deregister
     */

  }, {
    key: "removeAccountChangeListener",
    value: function () {
      var _removeAccountChangeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee33(id) {
        var subInfo;
        return _regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                if (!this._accountChangeSubscriptions[id]) {
                  _context33.next = 8;
                  break;
                }

                subInfo = this._accountChangeSubscriptions[id];
                delete this._accountChangeSubscriptions[id];
                _context33.next = 5;
                return this._unsubscribe(subInfo, 'accountUnsubscribe');

              case 5:
                this._updateSubscriptions();

                _context33.next = 9;
                break;

              case 8:
                throw new Error("Unknown account change id: ".concat(id));

              case 9:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function removeAccountChangeListener(_x46) {
        return _removeAccountChangeListener.apply(this, arguments);
      }

      return removeAccountChangeListener;
    }()
    /**
     * @private
     */

  }, {
    key: "_wsOnProgramAccountNotification",
    value: function _wsOnProgramAccountNotification(notification) {
      var res = ProgramAccountNotificationResult(notification);

      if (res.error) {
        throw new Error(res.error.message);
      }

      var keys = Object.keys(this._programAccountChangeSubscriptions).map(Number);
      var _iteratorNormalCompletion10 = true;
      var _didIteratorError10 = false;
      var _iteratorError10 = undefined;

      try {
        for (var _iterator10 = keys[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
          var id = _step10.value;
          var sub = this._programAccountChangeSubscriptions[id];

          if (sub.subscriptionId === res.subscription) {
            var result = res.result;
            assert(typeof result !== 'undefined');
            sub.callback({
              accountId: result.pubkey,
              accountInfo: {
                executable: result.account.executable,
                owner: new PublicKey(result.account.owner),
                lamports: result.account.lamports,
                data: bs58.decode(result.account.data)
              }
            });
            return true;
          }
        }
      } catch (err) {
        _didIteratorError10 = true;
        _iteratorError10 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
            _iterator10["return"]();
          }
        } finally {
          if (_didIteratorError10) {
            throw _iteratorError10;
          }
        }
      }
    }
    /**
     * Register a callback to be invoked whenever accounts owned by the
     * specified program change
     *
     * @param programId Public key of the program to monitor
     * @param callback Function to invoke whenever the account is changed
     * @return subscription id
     */

  }, {
    key: "onProgramAccountChange",
    value: function onProgramAccountChange(programId, callback) {
      var id = ++this._programAccountChangeSubscriptionCounter;
      this._programAccountChangeSubscriptions[id] = {
        programId: programId.toBase58(),
        callback: callback,
        subscriptionId: null
      };

      this._updateSubscriptions();

      return id;
    }
    /**
     * Deregister an account notification callback
     *
     * @param id subscription id to deregister
     */

  }, {
    key: "removeProgramAccountChangeListener",
    value: function () {
      var _removeProgramAccountChangeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee34(id) {
        var subInfo;
        return _regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                if (!this._programAccountChangeSubscriptions[id]) {
                  _context34.next = 8;
                  break;
                }

                subInfo = this._programAccountChangeSubscriptions[id];
                delete this._programAccountChangeSubscriptions[id];
                _context34.next = 5;
                return this._unsubscribe(subInfo, 'programUnsubscribe');

              case 5:
                this._updateSubscriptions();

                _context34.next = 9;
                break;

              case 8:
                throw new Error("Unknown program account change id: ".concat(id));

              case 9:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function removeProgramAccountChangeListener(_x47) {
        return _removeProgramAccountChangeListener.apply(this, arguments);
      }

      return removeProgramAccountChangeListener;
    }()
    /**
     * @private
     */

  }, {
    key: "_wsOnSlotNotification",
    value: function _wsOnSlotNotification(notification) {
      var res = SlotNotificationResult(notification);

      if (res.error) {
        throw new Error(res.error.message);
      }

      assert(typeof res.result !== 'undefined');
      var _res$result = res.result,
          parent = _res$result.parent,
          slot = _res$result.slot,
          root = _res$result.root;
      var keys = Object.keys(this._slotSubscriptions).map(Number);
      var _iteratorNormalCompletion11 = true;
      var _didIteratorError11 = false;
      var _iteratorError11 = undefined;

      try {
        for (var _iterator11 = keys[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
          var id = _step11.value;
          var sub = this._slotSubscriptions[id];

          if (sub.subscriptionId === res.subscription) {
            sub.callback({
              parent: parent,
              slot: slot,
              root: root
            });
            return true;
          }
        }
      } catch (err) {
        _didIteratorError11 = true;
        _iteratorError11 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
            _iterator11["return"]();
          }
        } finally {
          if (_didIteratorError11) {
            throw _iteratorError11;
          }
        }
      }
    }
    /**
     * Register a callback to be invoked upon slot changes
     *
     * @param callback Function to invoke whenever the slot changes
     * @return subscription id
     */

  }, {
    key: "onSlotChange",
    value: function onSlotChange(callback) {
      var id = ++this._slotSubscriptionCounter;
      this._slotSubscriptions[id] = {
        callback: callback,
        subscriptionId: null
      };

      this._updateSubscriptions();

      return id;
    }
    /**
     * Deregister a slot notification callback
     *
     * @param id subscription id to deregister
     */

  }, {
    key: "removeSlotChangeListener",
    value: function () {
      var _removeSlotChangeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee35(id) {
        var subInfo;
        return _regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                if (!this._slotSubscriptions[id]) {
                  _context35.next = 8;
                  break;
                }

                subInfo = this._slotSubscriptions[id];
                delete this._slotSubscriptions[id];
                _context35.next = 5;
                return this._unsubscribe(subInfo, 'slotUnsubscribe');

              case 5:
                this._updateSubscriptions();

                _context35.next = 9;
                break;

              case 8:
                throw new Error("Unknown slot change id: ".concat(id));

              case 9:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function removeSlotChangeListener(_x48) {
        return _removeSlotChangeListener.apply(this, arguments);
      }

      return removeSlotChangeListener;
    }()
  }, {
    key: "_argsWithCommitment",
    value: function _argsWithCommitment(args, override) {
      var commitment = override || this._commitment;

      if (commitment) {
        args.push({
          commitment: commitment
        });
      }

      return args;
    }
    /**
     * @private
     */

  }, {
    key: "_wsOnSignatureNotification",
    value: function _wsOnSignatureNotification(notification) {
      var res = SignatureNotificationResult(notification);

      if (res.error) {
        throw new Error(res.error.message);
      }

      assert(typeof res.result !== 'undefined');
      var keys = Object.keys(this._signatureSubscriptions).map(Number);
      var _iteratorNormalCompletion12 = true;
      var _didIteratorError12 = false;
      var _iteratorError12 = undefined;

      try {
        for (var _iterator12 = keys[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var id = _step12.value;
          var sub = this._signatureSubscriptions[id];

          if (sub.subscriptionId === res.subscription) {
            // Signatures subscriptions are auto-removed by the RPC service so
            // no need to explicitly send an unsubscribe message
            delete this._signatureSubscriptions[id];

            this._updateSubscriptions();

            sub.callback(res.result);
            return;
          }
        }
      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
            _iterator12["return"]();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }
    }
    /**
     * Register a callback to be invoked upon signature updates
     *
     * @param signature Transaction signature string in base 58
     * @param callback Function to invoke on signature notifications
     * @return subscription id
     */

  }, {
    key: "onSignature",
    value: function onSignature(signature, callback) {
      var id = ++this._signatureSubscriptionCounter;
      this._signatureSubscriptions[id] = {
        signature: signature,
        callback: callback,
        subscriptionId: null
      };

      this._updateSubscriptions();

      return id;
    }
    /**
     * Deregister a signature notification callback
     *
     * @param id subscription id to deregister
     */

  }, {
    key: "removeSignatureListener",
    value: function () {
      var _removeSignatureListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee36(id) {
        var subInfo;
        return _regeneratorRuntime.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                if (!this._signatureSubscriptions[id]) {
                  _context36.next = 8;
                  break;
                }

                subInfo = this._signatureSubscriptions[id];
                delete this._signatureSubscriptions[id];
                _context36.next = 5;
                return this._unsubscribe(subInfo, 'signatureUnsubscribe');

              case 5:
                this._updateSubscriptions();

                _context36.next = 9;
                break;

              case 8:
                throw new Error("Unknown signature result id: ".concat(id));

              case 9:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function removeSignatureListener(_x49) {
        return _removeSignatureListener.apply(this, arguments);
      }

      return removeSignatureListener;
    }()
  }]);

  return Connection;
}();

/**
 * Sign, send and confirm a transaction with recent commitment level
 */

function sendAndConfirmRecentTransaction(_x, _x2) {
  return _sendAndConfirmRecentTransaction.apply(this, arguments);
}
/**
 * Sign, send and confirm a transaction
 */

function _sendAndConfirmRecentTransaction() {
  _sendAndConfirmRecentTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection, transaction) {
    var _len,
        signers,
        _key,
        _args = arguments;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            for (_len = _args.length, signers = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              signers[_key - 2] = _args[_key];
            }

            _context.next = 3;
            return _sendAndConfirmTransaction(connection, transaction, signers, 'recent');

          case 3:
            return _context.abrupt("return", _context.sent);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _sendAndConfirmRecentTransaction.apply(this, arguments);
}

function sendAndConfirmTransaction(_x3, _x4) {
  return _sendAndConfirmTransaction2.apply(this, arguments);
}

function _sendAndConfirmTransaction2() {
  _sendAndConfirmTransaction2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(connection, transaction) {
    var _len2,
        signers,
        _key2,
        _args2 = arguments;

    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            for (_len2 = _args2.length, signers = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
              signers[_key2 - 2] = _args2[_key2];
            }

            _context2.next = 3;
            return _sendAndConfirmTransaction(connection, transaction, signers);

          case 3:
            return _context2.abrupt("return", _context2.sent);

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _sendAndConfirmTransaction2.apply(this, arguments);
}

function _sendAndConfirmTransaction(_x5, _x6, _x7, _x8) {
  return _sendAndConfirmTransaction3.apply(this, arguments);
}

function _sendAndConfirmTransaction3() {
  _sendAndConfirmTransaction3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(connection, transaction, signers, commitment) {
    var sendRetries, signature, start, status, statusRetries, duration;
    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            sendRetries = 10;

          case 1:
            start = Date.now();
            _context3.next = 4;
            return connection.sendTransaction.apply(connection, [transaction].concat(_toConsumableArray(signers)));

          case 4:
            signature = _context3.sent;
            // Wait up to a couple slots for a confirmation
            status = null;
            statusRetries = 6;

          case 7:
            _context3.next = 9;
            return connection.getSignatureStatus(signature, commitment);

          case 9:
            status = _context3.sent;

            if (!status) {
              _context3.next = 12;
              break;
            }

            return _context3.abrupt("break", 18);

          case 12:
            if (!(--statusRetries <= 0)) {
              _context3.next = 14;
              break;
            }

            return _context3.abrupt("break", 18);

          case 14:
            _context3.next = 16;
            return sleep(500 * DEFAULT_TICKS_PER_SLOT / NUM_TICKS_PER_SECOND);

          case 16:
            _context3.next = 7;
            break;

          case 18:
            if (!(status && 'Ok' in status)) {
              _context3.next = 20;
              break;
            }

            return _context3.abrupt("break", 29);

          case 20:
            if (!(--sendRetries <= 0)) {
              _context3.next = 23;
              break;
            }

            duration = (Date.now() - start) / 1000;
            throw new Error("Transaction '".concat(signature, "' was not confirmed in ").concat(duration.toFixed(2), " seconds (").concat(JSON.stringify(status), ")"));

          case 23:
            if (!(status && status.Err && !('AccountInUse' in status.Err))) {
              _context3.next = 25;
              break;
            }

            throw new Error("Transaction ".concat(signature, " failed (").concat(JSON.stringify(status), ")"));

          case 25:
            _context3.next = 27;
            return sleep(Math.random() * 100);

          case 27:
            _context3.next = 1;
            break;

          case 29:
            assert(signature !== undefined);
            return _context3.abrupt("return", signature);

          case 31:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _sendAndConfirmTransaction3.apply(this, arguments);
}

/**
 * @typedef {Object} InstructionType
 * @property (index} The Instruction index (from solana upstream program)
 * @property (BufferLayout} The BufferLayout to use to build data
 */

/**
 * Populate a buffer of instruction data using an InstructionType
 */
function encodeData(type, fields) {
  var allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);
  var data = Buffer.alloc(allocLength);
  var layoutFields = Object.assign({
    instruction: type.index
  }, fields);
  type.layout.encode(layoutFields, data);
  return data;
}
/**
 * Decode instruction data buffer using an InstructionType
 */

function decodeData(type, buffer) {
  var data;

  try {
    data = type.layout.decode(buffer);
  } catch (err) {
    throw new Error('invalid instruction; ' + err);
  }

  if (data.instruction !== type.index) {
    throw new Error("invalid instruction; instruction index mismatch ".concat(data.instruction, " != ").concat(type.index));
  }

  return data;
}

/**
 * Create account system transaction params
 * @typedef {Object} CreateAccountParams
 * @property {PublicKey} fromPubkey
 * @property {PublicKey} newAccountPubkey
 * @property {number} lamports
 * @property {number} space
 * @property {PublicKey} programId
 */

/**
 * System Instruction class
 */
var SystemInstruction = /*#__PURE__*/function () {
  function SystemInstruction() {
    _classCallCheck(this, SystemInstruction);
  }

  _createClass(SystemInstruction, null, [{
    key: "decodeInstructionType",

    /**
     * Decode a system instruction and retrieve the instruction type.
     */
    value: function decodeInstructionType(instruction) {
      this.checkProgramId(instruction.programId);
      var instructionTypeLayout = u32('instruction');
      var typeIndex = instructionTypeLayout.decode(instruction.data);
      var type;

      for (var _i = 0, _Object$keys = Object.keys(SYSTEM_INSTRUCTION_LAYOUTS); _i < _Object$keys.length; _i++) {
        var t = _Object$keys[_i];

        if (SYSTEM_INSTRUCTION_LAYOUTS[t].index == typeIndex) {
          type = t;
        }
      }

      if (!type) {
        throw new Error('Instruction type incorrect; not a SystemInstruction');
      }

      return type;
    }
    /**
     * Decode a create account system instruction and retrieve the instruction params.
     */

  }, {
    key: "decodeCreateAccount",
    value: function decodeCreateAccount(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);

      var _decodeData = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data),
          lamports = _decodeData.lamports,
          space = _decodeData.space,
          programId = _decodeData.programId;

      return {
        fromPubkey: instruction.keys[0].pubkey,
        newAccountPubkey: instruction.keys[1].pubkey,
        lamports: lamports,
        space: space,
        programId: new PublicKey(programId)
      };
    }
    /**
     * Decode a transfer system instruction and retrieve the instruction params.
     */

  }, {
    key: "decodeTransfer",
    value: function decodeTransfer(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);

      var _decodeData2 = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data),
          lamports = _decodeData2.lamports;

      return {
        fromPubkey: instruction.keys[0].pubkey,
        toPubkey: instruction.keys[1].pubkey,
        lamports: lamports
      };
    }
    /**
     * Decode an assign system instruction and retrieve the instruction params.
     */

  }, {
    key: "decodeAssign",
    value: function decodeAssign(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 1);

      var _decodeData3 = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data),
          programId = _decodeData3.programId;

      return {
        fromPubkey: instruction.keys[0].pubkey,
        programId: new PublicKey(programId)
      };
    }
    /**
     * Decode a create account with seed system instruction and retrieve the instruction params.
     */

  }, {
    key: "decodeCreateWithSeed",
    value: function decodeCreateWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);

      var _decodeData4 = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data),
          base = _decodeData4.base,
          seed = _decodeData4.seed,
          lamports = _decodeData4.lamports,
          space = _decodeData4.space,
          programId = _decodeData4.programId;

      return {
        fromPubkey: instruction.keys[0].pubkey,
        newAccountPubkey: instruction.keys[1].pubkey,
        basePubkey: new PublicKey(base),
        seed: seed,
        lamports: lamports,
        space: space,
        programId: new PublicKey(programId)
      };
    }
    /**
     * Decode a nonce initialize system instruction and retrieve the instruction params.
     */

  }, {
    key: "decodeNonceInitialize",
    value: function decodeNonceInitialize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);

      var _decodeData5 = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data),
          authorized = _decodeData5.authorized;

      return {
        noncePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: new PublicKey(authorized)
      };
    }
    /**
     * Decode a nonce advance system instruction and retrieve the instruction params.
     */

  }, {
    key: "decodeNonceAdvance",
    value: function decodeNonceAdvance(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      decodeData(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);
      return {
        noncePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[2].pubkey
      };
    }
    /**
     * Decode a nonce withdraw system instruction and retrieve the instruction params.
     */

  }, {
    key: "decodeNonceWithdraw",
    value: function decodeNonceWithdraw(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 5);

      var _decodeData6 = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data),
          lamports = _decodeData6.lamports;

      return {
        noncePubkey: instruction.keys[0].pubkey,
        toPubkey: instruction.keys[1].pubkey,
        authorizedPubkey: instruction.keys[4].pubkey,
        lamports: lamports
      };
    }
    /**
     * Decode a nonce authorize system instruction and retrieve the instruction params.
     */

  }, {
    key: "decodeNonceAuthorize",
    value: function decodeNonceAuthorize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);

      var _decodeData7 = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data),
          authorized = _decodeData7.authorized;

      return {
        noncePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[1].pubkey,
        newAuthorizedPubkey: new PublicKey(authorized)
      };
    }
    /**
     * @private
     */

  }, {
    key: "checkProgramId",
    value: function checkProgramId(programId) {
      if (!programId.equals(SystemProgram.programId)) {
        throw new Error('invalid instruction; programId is not SystemProgram');
      }
    }
    /**
     * @private
     */

  }, {
    key: "checkKeyLength",
    value: function checkKeyLength(keys, expectedLength) {
      if (keys.length !== expectedLength) {
        throw new Error("invalid instruction; key length mismatch ".concat(keys.length, " != ").concat(expectedLength));
      }
    }
  }]);

  return SystemInstruction;
}();
/**
 * An enumeration of valid SystemInstructionType's
 * @typedef {'Create' | 'Assign' | 'Transfer' | 'CreateWithSeed'
 | 'AdvanceNonceAccount' | 'WithdrawNonceAccount' | 'InitializeNonceAccount'
 | 'AuthorizeNonceAccount'} SystemInstructionType
 */

/**
 * An enumeration of valid system InstructionType's
 */
var SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
  Create: {
    index: 0,
    layout: struct([u32('instruction'), ns64('lamports'), ns64('space'), publicKey('programId')])
  },
  Assign: {
    index: 1,
    layout: struct([u32('instruction'), publicKey('programId')])
  },
  Transfer: {
    index: 2,
    layout: struct([u32('instruction'), ns64('lamports')])
  },
  CreateWithSeed: {
    index: 3,
    layout: struct([u32('instruction'), publicKey('base'), rustString('seed'), ns64('lamports'), ns64('space'), publicKey('programId')])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: struct([u32('instruction')])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: struct([u32('instruction'), ns64('lamports')])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: struct([u32('instruction'), publicKey('authorized')])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: struct([u32('instruction'), publicKey('authorized')])
  }
});
/**
 * Factory class for transactions to interact with the System program
 */

var SystemProgram = /*#__PURE__*/function () {
  function SystemProgram() {
    _classCallCheck(this, SystemProgram);
  }

  _createClass(SystemProgram, null, [{
    key: "createAccount",

    /**
     * Generate a Transaction that creates a new account
     */
    value: function createAccount(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.Create;
      var data = encodeData(type, {
        lamports: params.lamports,
        space: params.space,
        programId: params.programId.toBuffer()
      });
      return new Transaction().add({
        keys: [{
          pubkey: params.fromPubkey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: params.newAccountPubkey,
          isSigner: true,
          isWritable: true
        }],
        programId: this.programId,
        data: data
      });
    }
    /**
     * Generate a Transaction that transfers lamports from one account to another
     */

  }, {
    key: "transfer",
    value: function transfer(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
      var data = encodeData(type, {
        lamports: params.lamports
      });
      return new Transaction().add({
        keys: [{
          pubkey: params.fromPubkey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: params.toPubkey,
          isSigner: false,
          isWritable: true
        }],
        programId: this.programId,
        data: data
      });
    }
    /**
     * Generate a Transaction that assigns an account to a program
     */

  }, {
    key: "assign",
    value: function assign(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
      var data = encodeData(type, {
        programId: params.programId.toBuffer()
      });
      return new Transaction().add({
        keys: [{
          pubkey: params.fromPubkey,
          isSigner: true,
          isWritable: true
        }],
        programId: this.programId,
        data: data
      });
    }
    /**
     * Generate a Transaction that creates a new account at
     *   an address generated with `from`, a seed, and programId
     */

  }, {
    key: "createAccountWithSeed",
    value: function createAccountWithSeed(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
      var data = encodeData(type, {
        base: params.basePubkey.toBuffer(),
        seed: params.seed,
        lamports: params.lamports,
        space: params.space,
        programId: params.programId.toBuffer()
      });
      return new Transaction().add({
        keys: [{
          pubkey: params.fromPubkey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: params.newAccountPubkey,
          isSigner: false,
          isWritable: true
        }],
        programId: this.programId,
        data: data
      });
    }
    /**
     * Generate a Transaction that creates a new Nonce account
     */

  }, {
    key: "createNonceAccount",
    value: function createNonceAccount(params) {
      var transaction = SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      });
      var initParams = {
        noncePubkey: params.noncePubkey,
        authorizedPubkey: params.authorizedPubkey
      };
      transaction.add(this.nonceInitialize(initParams));
      return transaction;
    }
    /**
     * Generate an instruction to initialize a Nonce account
     */

  }, {
    key: "nonceInitialize",
    value: function nonceInitialize(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
      var data = encodeData(type, {
        authorized: params.authorizedPubkey.toBuffer()
      });
      var instructionData = {
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      };
      return new TransactionInstruction(instructionData);
    }
    /**
     * Generate an instruction to advance the nonce in a Nonce account
     */

  }, {
    key: "nonceAdvance",
    value: function nonceAdvance(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
      var data = encodeData(type);
      var instructionData = {
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: params.authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      };
      return new TransactionInstruction(instructionData);
    }
    /**
     * Generate a Transaction that withdraws lamports from a Nonce account
     */

  }, {
    key: "nonceWithdraw",
    value: function nonceWithdraw(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
      var data = encodeData(type, {
        lamports: params.lamports
      });
      return new Transaction().add({
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.toPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: params.authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }
    /**
     * Generate a Transaction that authorizes a new PublicKey as the authority
     * on a Nonce account.
     */

  }, {
    key: "nonceAuthorize",
    value: function nonceAuthorize(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
      var data = encodeData(type, {
        authorized: params.newAuthorizedPubkey.toBuffer()
      });
      return new Transaction().add({
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }
  }, {
    key: "programId",

    /**
     * Public key that identifies the System program
     */
    get: function get() {
      return new PublicKey('0x000000000000000000000000000000000000000000000000000000000000000');
    }
  }]);

  return SystemProgram;
}();

/**
 * Program loader interface
 */

var Loader = /*#__PURE__*/function () {
  function Loader() {
    _classCallCheck(this, Loader);
  }

  _createClass(Loader, null, [{
    key: "getMinNumSignatures",

    /**
     * Minimum number of signatures required to load a program not including
     * retries
     *
     * Can be used to calculate transaction fees
     */
    value: function getMinNumSignatures(dataLength) {
      return Math.ceil(dataLength / Loader.chunkSize);
    }
    /**
     * Loads a generic program
     *
     * @param connection The connection to use
     * @param payer System account that pays to load the program
     * @param program Account to load the program into
     * @param programId Public key that identifies the loader
     * @param data Program octets
     */

  }, {
    key: "load",
    value: function () {
      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection, payer, program, programId, data) {
        var balanceNeeded, transaction, dataLayout, chunkSize, offset$1, array, transactions, bytes, _data, _transaction, _dataLayout, _data2, _transaction2;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return connection.getMinimumBalanceForRentExemption(data.length);

              case 2:
                balanceNeeded = _context.sent;
                transaction = SystemProgram.createAccount({
                  fromPubkey: payer.publicKey,
                  newAccountPubkey: program.publicKey,
                  lamports: balanceNeeded > 0 ? balanceNeeded : 1,
                  space: data.length,
                  programId: programId
                });
                _context.next = 6;
                return sendAndConfirmTransaction(connection, transaction, payer, program);

              case 6:
                dataLayout = struct([u32('instruction'), u32('offset'), u32('bytesLength'), u32('bytesLengthPadding'), seq(u8('byte'), offset(u32(), -8), 'bytes')]);
                chunkSize = Loader.chunkSize;
                offset$1 = 0;
                array = data;
                transactions = [];

              case 11:
                if (!(array.length > 0)) {
                  _context.next = 27;
                  break;
                }

                bytes = array.slice(0, chunkSize);
                _data = Buffer.alloc(chunkSize + 16);
                dataLayout.encode({
                  instruction: 0,
                  // Load instruction
                  offset: offset$1,
                  bytes: bytes
                }, _data);
                _transaction = new Transaction().add({
                  keys: [{
                    pubkey: program.publicKey,
                    isSigner: true,
                    isWritable: true
                  }],
                  programId: programId,
                  data: _data
                });
                transactions.push(sendAndConfirmTransaction(connection, _transaction, payer, program)); // Delay ~1 tick between write transactions in an attempt to reduce AccountInUse errors
                // since all the write transactions modify the same program account

                _context.next = 19;
                return sleep(1000 / NUM_TICKS_PER_SECOND);

              case 19:
                if (!(transactions.length === 8)) {
                  _context.next = 23;
                  break;
                }

                _context.next = 22;
                return Promise.all(transactions);

              case 22:
                transactions = [];

              case 23:
                offset$1 += chunkSize;
                array = array.slice(chunkSize);
                _context.next = 11;
                break;

              case 27:
                _context.next = 29;
                return Promise.all(transactions);

              case 29:
                _dataLayout = struct([u32('instruction')]);
                _data2 = Buffer.alloc(_dataLayout.span);

                _dataLayout.encode({
                  instruction: 1 // Finalize instruction

                }, _data2);

                _transaction2 = new Transaction().add({
                  keys: [{
                    pubkey: program.publicKey,
                    isSigner: true,
                    isWritable: true
                  }, {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false
                  }],
                  programId: programId,
                  data: _data2
                });
                _context.next = 35;
                return sendAndConfirmTransaction(connection, _transaction2, payer, program);

              case 35:
                return _context.abrupt("return", program.publicKey);

              case 36:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function load(_x, _x2, _x3, _x4, _x5) {
        return _load.apply(this, arguments);
      }

      return load;
    }()
  }, {
    key: "chunkSize",

    /**
     * Amount of program data placed in each load Transaction
     */
    get: function get() {
      // Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the
      // rest of the Transaction fields
      //
      // TODO: replace 300 with a proper constant for the size of the other
      // Transaction fields
      return PACKET_DATA_SIZE - 300;
    }
  }]);

  return Loader;
}();

/**
 * Factory class for transactions to interact with a program loader
 */
var BpfLoader = /*#__PURE__*/function () {
  function BpfLoader() {
    _classCallCheck(this, BpfLoader);
  }

  _createClass(BpfLoader, null, [{
    key: "getMinNumSignatures",

    /**
     * Minimum number of signatures required to load a program not including
     * retries
     *
     * Can be used to calculate transaction fees
     */
    value: function getMinNumSignatures(dataLength) {
      return Loader.getMinNumSignatures(dataLength);
    }
    /**
     * Load a BPF program
     *
     * @param connection The connection to use
     * @param owner User account to load the program into
     * @param elfBytes The entire ELF containing the BPF program
     */

  }, {
    key: "load",
    value: function load(connection, payer, elf) {
      var program = new Account();
      return Loader.load(connection, payer, program, BpfLoader.programId, elf);
    }
  }, {
    key: "programId",

    /**
     * Public key that identifies the BpfLoader
     */
    get: function get() {
      return new PublicKey('BPFLoader1111111111111111111111111111111111');
    }
  }]);

  return BpfLoader;
}();

/**
 * Represents a condition that is met by executing a `applySignature()`
 * transaction
 *
 * @typedef {Object} SignatureCondition
 * @property {string} type Must equal the string 'timestamp'
 * @property {PublicKey} from Public key from which `applySignature()` will be accepted from
 */

/**
 * @private
 */
function serializePayment(payment) {
  var toData = payment.to.toBuffer();
  var data = Buffer.alloc(8 + toData.length);
  data.writeUInt32LE(payment.amount, 0);
  toData.copy(data, 8);
  return data;
}
/**
 * @private
 */


function serializeDate(when) {
  var data = Buffer.alloc(8 + 20);
  data.writeUInt32LE(20, 0); // size of timestamp as u64

  function iso(date) {
    function pad(number) {
      if (number < 10) {
        return '0' + number;
      }

      return number;
    }

    return date.getUTCFullYear() + '-' + pad(date.getUTCMonth() + 1) + '-' + pad(date.getUTCDate()) + 'T' + pad(date.getUTCHours()) + ':' + pad(date.getUTCMinutes()) + ':' + pad(date.getUTCSeconds()) + 'Z';
  }

  data.write(iso(when), 8);
  return data;
}
/**
 * @private
 */


function serializeCondition(condition) {
  switch (condition.type) {
    case 'timestamp':
      {
        var date = serializeDate(condition.when);
        var from = condition.from.toBuffer();
        var data = Buffer.alloc(4 + date.length + from.length);
        data.writeUInt32LE(0, 0); // Condition enum = Timestamp

        date.copy(data, 4);
        from.copy(data, 4 + date.length);
        return data;
      }

    case 'signature':
      {
        var _from = condition.from.toBuffer();

        var _data = Buffer.alloc(4 + _from.length);

        _data.writeUInt32LE(1, 0); // Condition enum = Signature


        _from.copy(_data, 4);

        return _data;
      }

    default:
      throw new Error("Unknown condition type: ".concat(condition.type));
  }
}
/**
 * Factory class for transactions to interact with the Budget program
 */


var BudgetProgram = /*#__PURE__*/function () {
  function BudgetProgram() {
    _classCallCheck(this, BudgetProgram);
  }

  _createClass(BudgetProgram, null, [{
    key: "timestampCondition",

    /**
     * Creates a timestamp condition
     */
    value: function timestampCondition(from, when) {
      return {
        type: 'timestamp',
        from: from,
        when: when
      };
    }
    /**
     * Creates a signature condition
     */

  }, {
    key: "signatureCondition",
    value: function signatureCondition(from) {
      return {
        type: 'signature',
        from: from
      };
    }
    /**
     * Generates a transaction that transfers lamports once any of the conditions are met
     */

  }, {
    key: "pay",
    value: function pay(from, program, to, amount) {
      var data = Buffer.alloc(1024);
      var pos = 0;
      data.writeUInt32LE(0, pos); // NewBudget instruction

      pos += 4;

      for (var _len = arguments.length, conditions = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
        conditions[_key - 4] = arguments[_key];
      }

      switch (conditions.length) {
        case 0:
          {
            data.writeUInt32LE(0, pos); // BudgetExpr enum = Pay

            pos += 4;
            {
              var payment = serializePayment({
                amount: amount,
                to: to
              });
              payment.copy(data, pos);
              pos += payment.length;
            }
            var trimmedData = data.slice(0, pos);
            var transaction = SystemProgram.createAccount({
              fromPubkey: from,
              newAccountPubkey: program,
              lamports: amount,
              space: trimmedData.length,
              programId: this.programId
            });
            return transaction.add({
              keys: [{
                pubkey: to,
                isSigner: false,
                isWritable: true
              }, {
                pubkey: program,
                isSigner: false,
                isWritable: true
              }],
              programId: this.programId,
              data: trimmedData
            });
          }

        case 1:
          {
            data.writeUInt32LE(1, pos); // BudgetExpr enum = After

            pos += 4;
            {
              var condition = conditions[0];
              var conditionData = serializeCondition(condition);
              conditionData.copy(data, pos);
              pos += conditionData.length;
              data.writeUInt32LE(0, pos); // BudgetExpr enum = Pay

              pos += 4;
              var paymentData = serializePayment({
                amount: amount,
                to: to
              });
              paymentData.copy(data, pos);
              pos += paymentData.length;
            }

            var _trimmedData = data.slice(0, pos);

            var _transaction = SystemProgram.createAccount({
              fromPubkey: from,
              newAccountPubkey: program,
              lamports: amount,
              space: _trimmedData.length,
              programId: this.programId
            });

            return _transaction.add({
              keys: [{
                pubkey: program,
                isSigner: false,
                isWritable: true
              }],
              programId: this.programId,
              data: _trimmedData
            });
          }

        case 2:
          {
            data.writeUInt32LE(2, pos); // BudgetExpr enum = Or

            pos += 4;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = conditions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _condition = _step.value;

                var _conditionData = serializeCondition(_condition);

                _conditionData.copy(data, pos);

                pos += _conditionData.length;
                data.writeUInt32LE(0, pos); // BudgetExpr enum = Pay

                pos += 4;

                var _paymentData = serializePayment({
                  amount: amount,
                  to: to
                });

                _paymentData.copy(data, pos);

                pos += _paymentData.length;
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            var _trimmedData2 = data.slice(0, pos);

            var _transaction2 = SystemProgram.createAccount({
              fromPubkey: from,
              newAccountPubkey: program,
              lamports: amount,
              space: _trimmedData2.length,
              programId: this.programId
            });

            return _transaction2.add({
              keys: [{
                pubkey: program,
                isSigner: false,
                isWritable: true
              }],
              programId: this.programId,
              data: _trimmedData2
            });
          }

        default:
          throw new Error("A maximum of two conditions are supported: ".concat(conditions.length, " provided"));
      }
    }
    /**
     * Generates a transaction that transfers lamports once both conditions are met
     */

  }, {
    key: "payOnBoth",
    value: function payOnBoth(from, program, to, amount, condition1, condition2) {
      var data = Buffer.alloc(1024);
      var pos = 0;
      data.writeUInt32LE(0, pos); // NewBudget instruction

      pos += 4;
      data.writeUInt32LE(3, pos); // BudgetExpr enum = And

      pos += 4;

      for (var _i = 0, _arr = [condition1, condition2]; _i < _arr.length; _i++) {
        var condition = _arr[_i];
        var conditionData = serializeCondition(condition);
        conditionData.copy(data, pos);
        pos += conditionData.length;
      }

      data.writeUInt32LE(0, pos); // BudgetExpr enum = Pay

      pos += 4;
      var paymentData = serializePayment({
        amount: amount,
        to: to
      });
      paymentData.copy(data, pos);
      pos += paymentData.length;
      var trimmedData = data.slice(0, pos);
      var transaction = SystemProgram.createAccount({
        fromPubkey: from,
        newAccountPubkey: program,
        lamports: amount,
        space: trimmedData.length,
        programId: this.programId
      });
      return transaction.add({
        keys: [{
          pubkey: program,
          isSigner: false,
          isWritable: true
        }],
        programId: this.programId,
        data: trimmedData
      });
    }
    /**
     * Generates a transaction that applies a timestamp, which could enable a
     * pending payment to proceed.
     */

  }, {
    key: "applyTimestamp",
    value: function applyTimestamp(from, program, to, when) {
      var whenData = serializeDate(when);
      var data = Buffer.alloc(4 + whenData.length);
      data.writeUInt32LE(1, 0); // ApplyTimestamp instruction

      whenData.copy(data, 4);
      return new Transaction().add({
        keys: [{
          pubkey: from,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: program,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: to,
          isSigner: false,
          isWritable: true
        }],
        programId: this.programId,
        data: data
      });
    }
    /**
     * Generates a transaction that applies a signature, which could enable a
     * pending payment to proceed.
     */

  }, {
    key: "applySignature",
    value: function applySignature(from, program, to) {
      var dataLayout = struct([u32('instruction')]);
      var data = Buffer.alloc(dataLayout.span);
      dataLayout.encode({
        instruction: 2 // ApplySignature instruction

      }, data);
      return new Transaction().add({
        keys: [{
          pubkey: from,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: program,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: to,
          isSigner: false,
          isWritable: true
        }],
        programId: this.programId,
        data: data
      });
    }
  }, {
    key: "programId",

    /**
     * Public key that identifies the Budget program
     */
    get: function get() {
      return new PublicKey('Budget1111111111111111111111111111111111111');
    }
    /**
     * The amount of space this program requires
     */

  }, {
    key: "space",
    get: function get() {
      return 128;
    }
  }]);

  return BudgetProgram;
}();

var STAKE_CONFIG_ID = new PublicKey('StakeConfig11111111111111111111111111111111');
var Authorized =
/**
 * Create a new Authorized object
 */
function Authorized(staker, withdrawer) {
  _classCallCheck(this, Authorized);

  _defineProperty(this, "staker", void 0);

  _defineProperty(this, "withdrawer", void 0);

  this.staker = staker;
  this.withdrawer = withdrawer;
};
var Lockup =
/**
 * Create a new Lockup object
 */
function Lockup(unixTimestamp, epoch, custodian) {
  _classCallCheck(this, Lockup);

  _defineProperty(this, "unixTimestamp", void 0);

  _defineProperty(this, "epoch", void 0);

  _defineProperty(this, "custodian", void 0);

  this.unixTimestamp = unixTimestamp;
  this.epoch = epoch;
  this.custodian = custodian;
};
/**
 * Create stake account transaction params
 * @typedef {Object} CreateStakeAccountParams
 * @property {PublicKey} fromPubkey
 * @property {PublicKey} stakePubkey
 * @property {Authorized} authorized
 * @property {Lockup} lockup
 * @property {number} lamports
 */

/**
 * Stake Instruction class
 */
var StakeInstruction = /*#__PURE__*/function () {
  function StakeInstruction() {
    _classCallCheck(this, StakeInstruction);
  }

  _createClass(StakeInstruction, null, [{
    key: "decodeInstructionType",

    /**
     * Decode a stake instruction and retrieve the instruction type.
     */
    value: function decodeInstructionType(instruction) {
      this.checkProgramId(instruction.programId);
      var instructionTypeLayout = u32('instruction');
      var typeIndex = instructionTypeLayout.decode(instruction.data);
      var type;

      for (var _i = 0, _Object$keys = Object.keys(STAKE_INSTRUCTION_LAYOUTS); _i < _Object$keys.length; _i++) {
        var t = _Object$keys[_i];

        if (STAKE_INSTRUCTION_LAYOUTS[t].index == typeIndex) {
          type = t;
        }
      }

      if (!type) {
        throw new Error('Instruction type incorrect; not a StakeInstruction');
      }

      return type;
    }
    /**
     * Decode a initialize stake instruction and retrieve the instruction params.
     */

  }, {
    key: "decodeInitialize",
    value: function decodeInitialize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);

      var _decodeData = decodeData(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data),
          authorized = _decodeData.authorized,
          lockup = _decodeData.lockup;

      return {
        stakePubkey: instruction.keys[0].pubkey,
        authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),
        lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))
      };
    }
    /**
     * Decode a delegate stake instruction and retrieve the instruction params.
     */

  }, {
    key: "decodeDelegate",
    value: function decodeDelegate(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 6);
      decodeData(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);
      return {
        stakePubkey: instruction.keys[0].pubkey,
        votePubkey: instruction.keys[1].pubkey,
        authorizedPubkey: instruction.keys[5].pubkey
      };
    }
    /**
     * Decode an authorize stake instruction and retrieve the instruction params.
     */

  }, {
    key: "decodeAuthorize",
    value: function decodeAuthorize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);

      var _decodeData2 = decodeData(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data),
          newAuthorized = _decodeData2.newAuthorized,
          stakeAuthorizationType = _decodeData2.stakeAuthorizationType;

      return {
        stakePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[2].pubkey,
        newAuthorizedPubkey: new PublicKey(newAuthorized),
        stakeAuthorizationType: {
          index: stakeAuthorizationType
        }
      };
    }
    /**
     * Decode a split stake instruction and retrieve the instruction params.
     */

  }, {
    key: "decodeSplit",
    value: function decodeSplit(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);

      var _decodeData3 = decodeData(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data),
          lamports = _decodeData3.lamports;

      return {
        stakePubkey: instruction.keys[0].pubkey,
        splitStakePubkey: instruction.keys[1].pubkey,
        authorizedPubkey: instruction.keys[2].pubkey,
        lamports: lamports
      };
    }
    /**
     * Decode a withdraw stake instruction and retrieve the instruction params.
     */

  }, {
    key: "decodeWithdraw",
    value: function decodeWithdraw(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 5);

      var _decodeData4 = decodeData(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data),
          lamports = _decodeData4.lamports;

      return {
        stakePubkey: instruction.keys[0].pubkey,
        toPubkey: instruction.keys[1].pubkey,
        authorizedPubkey: instruction.keys[4].pubkey,
        lamports: lamports
      };
    }
    /**
     * Decode a deactivate stake instruction and retrieve the instruction params.
     */

  }, {
    key: "decodeDeactivate",
    value: function decodeDeactivate(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      decodeData(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);
      return {
        stakePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[2].pubkey
      };
    }
    /**
     * @private
     */

  }, {
    key: "checkProgramId",
    value: function checkProgramId(programId) {
      if (!programId.equals(StakeProgram.programId)) {
        throw new Error('invalid instruction; programId is not StakeProgram');
      }
    }
    /**
     * @private
     */

  }, {
    key: "checkKeyLength",
    value: function checkKeyLength(keys, expectedLength) {
      if (keys.length !== expectedLength) {
        throw new Error("invalid instruction; key length mismatch ".concat(keys.length, " != ").concat(expectedLength));
      }
    }
  }]);

  return StakeInstruction;
}();
/**
 * An enumeration of valid StakeInstructionType's
 * @typedef { 'Initialize' | 'Authorize' | 'Delegate' | 'Split' | 'Withdraw'
 | 'Deactivate' } StakeInstructionType
 */

/**
 * An enumeration of valid stake InstructionType's
 */
var STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
  Initialize: {
    index: 0,
    layout: struct([u32('instruction'), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: struct([u32('instruction'), publicKey('newAuthorized'), u32('stakeAuthorizationType')])
  },
  Delegate: {
    index: 2,
    layout: struct([u32('instruction')])
  },
  Split: {
    index: 3,
    layout: struct([u32('instruction'), ns64('lamports')])
  },
  Withdraw: {
    index: 4,
    layout: struct([u32('instruction'), ns64('lamports')])
  },
  Deactivate: {
    index: 5,
    layout: struct([u32('instruction')])
  }
});
/**
 * @typedef {Object} StakeAuthorizationType
 * @property (index} The Stake Authorization index (from solana-stake-program)
 */

/**
 * An enumeration of valid StakeAuthorizationLayout's
 */
var StakeAuthorizationLayout = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
/**
 * Factory class for transactions to interact with the Stake program
 */

var StakeProgram = /*#__PURE__*/function () {
  function StakeProgram() {
    _classCallCheck(this, StakeProgram);
  }

  _createClass(StakeProgram, null, [{
    key: "initialize",

    /**
     * Generate an Initialize instruction to add to a Stake Create transaction
     */
    value: function initialize(params) {
      var stakePubkey = params.stakePubkey,
          authorized = params.authorized,
          lockup = params.lockup;
      var type = STAKE_INSTRUCTION_LAYOUTS.Initialize;
      var data = encodeData(type, {
        authorized: {
          staker: authorized.staker.toBuffer(),
          withdrawer: authorized.withdrawer.toBuffer()
        },
        lockup: {
          unixTimestamp: lockup.unixTimestamp,
          epoch: lockup.epoch,
          custodian: lockup.custodian.toBuffer()
        }
      });
      var instructionData = {
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      };
      return new TransactionInstruction(instructionData);
    }
    /**
     * Generate a Transaction that creates a new Stake account at
     *   an address generated with `from`, a seed, and the Stake programId
     */

  }, {
    key: "createAccountWithSeed",
    value: function createAccountWithSeed(params) {
      var transaction = SystemProgram.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.stakePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: this.space,
        programId: this.programId
      });
      var stakePubkey = params.stakePubkey,
          authorized = params.authorized,
          lockup = params.lockup;
      return transaction.add(this.initialize({
        stakePubkey: stakePubkey,
        authorized: authorized,
        lockup: lockup
      }));
    }
    /**
     * Generate a Transaction that creates a new Stake account
     */

  }, {
    key: "createAccount",
    value: function createAccount(params) {
      var transaction = SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.stakePubkey,
        lamports: params.lamports,
        space: this.space,
        programId: this.programId
      });
      var stakePubkey = params.stakePubkey,
          authorized = params.authorized,
          lockup = params.lockup;
      return transaction.add(this.initialize({
        stakePubkey: stakePubkey,
        authorized: authorized,
        lockup: lockup
      }));
    }
    /**
     * Generate a Transaction that delegates Stake tokens to a validator
     * Vote PublicKey. This transaction can also be used to redelegate Stake
     * to a new validator Vote PublicKey.
     */

  }, {
    key: "delegate",
    value: function delegate(params) {
      var stakePubkey = params.stakePubkey,
          authorizedPubkey = params.authorizedPubkey,
          votePubkey = params.votePubkey;
      var type = STAKE_INSTRUCTION_LAYOUTS.Delegate;
      var data = encodeData(type);
      return new Transaction().add({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: votePubkey,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: STAKE_CONFIG_ID,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }
    /**
     * Generate a Transaction that authorizes a new PublicKey as Staker
     * or Withdrawer on the Stake account.
     */

  }, {
    key: "authorize",
    value: function authorize(params) {
      var stakePubkey = params.stakePubkey,
          authorizedPubkey = params.authorizedPubkey,
          newAuthorizedPubkey = params.newAuthorizedPubkey,
          stakeAuthorizationType = params.stakeAuthorizationType;
      var type = STAKE_INSTRUCTION_LAYOUTS.Authorize;
      var data = encodeData(type, {
        newAuthorized: newAuthorizedPubkey.toBuffer(),
        stakeAuthorizationType: stakeAuthorizationType.index
      });
      return new Transaction().add({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }
    /**
     * Generate a Transaction that splits Stake tokens into another stake account
     */

  }, {
    key: "split",
    value: function split(params) {
      var stakePubkey = params.stakePubkey,
          authorizedPubkey = params.authorizedPubkey,
          splitStakePubkey = params.splitStakePubkey,
          lamports = params.lamports;
      var transaction = SystemProgram.createAccount({
        fromPubkey: stakePubkey,
        newAccountPubkey: splitStakePubkey,
        lamports: 0,
        space: this.space,
        programId: this.programId
      });
      transaction.instructions[0].keys[0].isSigner = false;
      var type = STAKE_INSTRUCTION_LAYOUTS.Split;
      var data = encodeData(type, {
        lamports: lamports
      });
      return transaction.add({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: splitStakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }
    /**
     * Generate a Transaction that withdraws deactivated Stake tokens.
     */

  }, {
    key: "withdraw",
    value: function withdraw(params) {
      var stakePubkey = params.stakePubkey,
          authorizedPubkey = params.authorizedPubkey,
          toPubkey = params.toPubkey,
          lamports = params.lamports;
      var type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
      var data = encodeData(type, {
        lamports: lamports
      });
      return new Transaction().add({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: toPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }
    /**
     * Generate a Transaction that deactivates Stake tokens.
     */

  }, {
    key: "deactivate",
    value: function deactivate(params) {
      var stakePubkey = params.stakePubkey,
          authorizedPubkey = params.authorizedPubkey;
      var type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
      var data = encodeData(type);
      return new Transaction().add({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }
  }, {
    key: "programId",

    /**
     * Public key that identifies the Stake program
     */
    get: function get() {
      return new PublicKey('Stake11111111111111111111111111111111111111');
    }
    /**
     * Max space of a Stake account
     */

  }, {
    key: "space",
    get: function get() {
      return 4008;
    }
  }]);

  return StakeProgram;
}();

var VALIDATOR_INFO_KEY = new PublicKey('Va1idator1nfo111111111111111111111111111111');
/**
 * @private
 */

var InfoString = struct$1({
  name: 'string',
  website: 'string?',
  details: 'string?',
  keybaseUsername: 'string?'
});
/**
 * ValidatorInfo class
 */

var ValidatorInfo = /*#__PURE__*/function () {
  /**
   * validator public key
   */

  /**
   * validator information
   */

  /**
   * Construct a valid ValidatorInfo
   *
   * @param key validator public key
   * @param info validator information
   */
  function ValidatorInfo(key, info) {
    _classCallCheck(this, ValidatorInfo);

    _defineProperty(this, "key", void 0);

    _defineProperty(this, "info", void 0);

    this.key = key;
    this.info = info;
  }
  /**
   * Deserialize ValidatorInfo from the config account data. Exactly two config
   * keys are required in the data.
   *
   * @param buffer config account data
   * @return null if info was not found
   */


  _createClass(ValidatorInfo, null, [{
    key: "fromConfigData",
    value: function fromConfigData(buffer) {
      var PUBKEY_LENGTH = 32;

      var byteArray = _toConsumableArray(buffer);

      var configKeyCount = decodeLength(byteArray);
      if (configKeyCount !== 2) return null;
      var configKeys = [];

      for (var i = 0; i < 2; i++) {
        var publicKey = new PublicKey(byteArray.slice(0, PUBKEY_LENGTH));
        byteArray = byteArray.slice(PUBKEY_LENGTH);
        var isSigner = byteArray.slice(0, 1)[0] === 1;
        byteArray = byteArray.slice(1);
        configKeys.push({
          publicKey: publicKey,
          isSigner: isSigner
        });
      }

      if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {
        if (configKeys[1].isSigner) {
          var rawInfo = rustString().decode(Buffer.from(byteArray));
          var info = InfoString(JSON.parse(rawInfo));
          return new ValidatorInfo(configKeys[1].publicKey, info);
        }
      }

      return null;
    }
  }]);

  return ValidatorInfo;
}();

var VOTE_PROGRAM_ID = new PublicKey('Vote111111111111111111111111111111111111111');

/**
 * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88
 *
 * @private
 */
var VoteAccountLayout = struct([publicKey('nodePubkey'), publicKey('authorizedVoterPubkey'), publicKey('authorizedWithdrawerPubkey'), u8('commission'), nu64(), // votes.length
seq(struct([nu64('slot'), u32('confirmationCount')]), offset(u32(), -8), 'votes'), u8('rootSlotValid'), nu64('rootSlot'), nu64('epoch'), nu64('credits'), nu64('lastEpochCredits'), nu64(), // epochCredits.length
seq(struct([nu64('epoch'), nu64('credits'), nu64('prevCredits')]), offset(u32(), -8), 'epochCredits')]);
/**
 * VoteAccount class
 */

var VoteAccount = /*#__PURE__*/function () {
  function VoteAccount() {
    _classCallCheck(this, VoteAccount);

    _defineProperty(this, "nodePubkey", void 0);

    _defineProperty(this, "authorizedVoterPubkey", void 0);

    _defineProperty(this, "authorizedWithdrawerPubkey", void 0);

    _defineProperty(this, "commission", void 0);

    _defineProperty(this, "votes", void 0);

    _defineProperty(this, "rootSlot", void 0);

    _defineProperty(this, "epoch", void 0);

    _defineProperty(this, "credits", void 0);

    _defineProperty(this, "lastEpochCredits", void 0);

    _defineProperty(this, "epochCredits", void 0);
  }

  _createClass(VoteAccount, null, [{
    key: "fromAccountData",

    /**
     * Deserialize VoteAccount from the account data.
     *
     * @param buffer account data
     * @return VoteAccount
     */
    value: function fromAccountData(buffer) {
      var va = VoteAccountLayout.decode(toBuffer(buffer), 0);
      va.nodePubkey = new PublicKey(va.nodePubkey);
      va.authorizedVoterPubkey = new PublicKey(va.authorizedVoterPubkey);
      va.authorizedWithdrawerPubkey = new PublicKey(va.authorizedWithdrawerPubkey);

      if (!va.rootSlotValid) {
        va.rootSlot = null;
      }

      return va;
    }
  }]);

  return VoteAccount;
}();

/**
 * Sign, send and confirm a raw transaction
 */

function sendAndConfirmRawTransaction(_x, _x2, _x3) {
  return _sendAndConfirmRawTransaction.apply(this, arguments);
}

function _sendAndConfirmRawTransaction() {
  _sendAndConfirmRawTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection, rawTransaction, commitment) {
    var start, signature, status, statusRetries, duration;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            start = Date.now();
            _context.next = 3;
            return connection.sendRawTransaction(rawTransaction);

          case 3:
            signature = _context.sent;
            // Wait up to a couple slots for a confirmation
            status = null;
            statusRetries = 6;

          case 6:
            _context.next = 8;
            return connection.getSignatureStatus(signature, commitment);

          case 8:
            status = _context.sent;

            if (!status) {
              _context.next = 11;
              break;
            }

            return _context.abrupt("break", 18);

          case 11:
            _context.next = 13;
            return sleep(500 * DEFAULT_TICKS_PER_SLOT / NUM_TICKS_PER_SECOND);

          case 13:
            if (!(--statusRetries <= 0)) {
              _context.next = 16;
              break;
            }

            duration = (Date.now() - start) / 1000;
            throw new Error("Raw Transaction '".concat(signature, "' was not confirmed in ").concat(duration.toFixed(2), " seconds (").concat(JSON.stringify(status), ")"));

          case 16:
            _context.next = 6;
            break;

          case 18:
            if (!(status && 'Ok' in status)) {
              _context.next = 20;
              break;
            }

            return _context.abrupt("return", signature);

          case 20:
            throw new Error("Raw transaction ".concat(signature, " failed (").concat(JSON.stringify(status), ")"));

          case 21:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _sendAndConfirmRawTransaction.apply(this, arguments);
}

var testnetDefaultChannel = "edge";

/**
 * @private
 */

var endpoint = {
  http: {
    edge: 'http://edge.devnet.solana.com:8899',
    beta: 'http://beta.devnet.solana.com:8899',
    stable: 'http://devnet.solana.com:8899'
  },
  https: {
    edge: 'https://edge.devnet.solana.com:8443',
    beta: 'https://beta.devnet.solana.com:8443',
    stable: 'https://devnet.solana.com:8443'
  }
};
/**
 * Retrieves the RPC endpoint URL for the specified testnet release
 * channel
 */

function testnetChannelEndpoint(channel, tls) {
  var key = tls === false ? 'http' : 'https';

  if (!channel) {
    return endpoint[key][testnetDefaultChannel];
  }

  var url = endpoint[key][channel];

  if (!url) {
    throw new Error("Unknown ".concat(key, " channel: ").concat(channel));
  }

  return url;
}

/**
 * There are 1-billion lamports in one SOL
 */

var LAMPORTS_PER_SOL = 1000000000;

export { Account, Authorized, BpfLoader, BudgetProgram, Connection, LAMPORTS_PER_SOL, Loader, Lockup, NonceAccount, PublicKey, STAKE_CONFIG_ID, STAKE_INSTRUCTION_LAYOUTS, SYSVAR_CLOCK_PUBKEY, SYSVAR_RENT_PUBKEY, SYSVAR_REWARDS_PUBKEY, SYSVAR_STAKE_HISTORY_PUBKEY, StakeAuthorizationLayout, StakeInstruction, StakeProgram, SystemInstruction, SystemProgram, Transaction, TransactionInstruction, VALIDATOR_INFO_KEY, VOTE_PROGRAM_ID, ValidatorInfo, VoteAccount, sendAndConfirmRawTransaction, sendAndConfirmRecentTransaction, sendAndConfirmTransaction, testnetChannelEndpoint };
//# sourceMappingURL=index.esm.js.map
